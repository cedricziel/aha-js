/* tslint:disable */
/* eslint-disable */
/**
 * Aha! REST API
 * API for interacting with Aha! product management platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { EpicsEpicIdCommentsGet200Response } from '../model';
// @ts-ignore
import type { IdeaCreateByPortalUserRequest } from '../model';
// @ts-ignore
import type { IdeaCreateRequest } from '../model';
// @ts-ignore
import type { IdeaEndorsementRequest } from '../model';
// @ts-ignore
import type { IdeaPromoteRequest } from '../model';
// @ts-ignore
import type { IdeaResponse } from '../model';
// @ts-ignore
import type { IdeaUpdateRequest } from '../model';
// @ts-ignore
import type { IdeaVoteRequest } from '../model';
// @ts-ignore
import type { IdeaWatchersRequest } from '../model';
// @ts-ignore
import type { IdeasCreateEndorsement201Response } from '../model';
// @ts-ignore
import type { IdeasGetEndorsements200Response } from '../model';
// @ts-ignore
import type { IdeasGetVotes200Response } from '../model';
// @ts-ignore
import type { IdeasGetWatchers200Response } from '../model';
// @ts-ignore
import type { IdeasListResponse } from '../model';
// @ts-ignore
import type { IdeasPromote200Response } from '../model';
// @ts-ignore
import type { IdeasVote200Response } from '../model';
/**
 * IdeasApi - axios parameter creator
 * @export
 */
export const IdeasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreate: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreate', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreate', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaEndorsementRequest} ideaEndorsementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateEndorsement: async (id: string, ideaEndorsementRequest: IdeaEndorsementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasCreateEndorsement', 'id', id)
            // verify required parameter 'ideaEndorsementRequest' is not null or undefined
            assertParamExists('ideasCreateEndorsement', 'ideaEndorsementRequest', ideaEndorsementRequest)
            const localVarPath = `/ideas/{id}/endorsements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaEndorsementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasDelete', 'id', id)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetById', 'id', id)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of endorsements per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetEndorsements: async (id: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetEndorsements', 'id', id)
            const localVarPath = `/ideas/{id}/endorsements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of votes per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetVotes: async (id: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetVotes', 'id', id)
            const localVarPath = `/ideas/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetWatchers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetWatchers', 'id', id)
            const localVarPath = `/ideas/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasIdeaIdCommentsGet: async (ideaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideasIdeaIdCommentsGet', 'ideaId', ideaId)
            const localVarPath = `/ideas/{idea_id}/comments`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {string} [q] Search term to match against idea name.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
         * @param {string} [assignedToUser] ID or email address of a user. If provided, returns only ideas assigned to that user.
         * @param {string} [status] Status filter for ideas.
         * @param {string} [category] Filter ideas by category.
         * @param {string} [productId] Filter ideas by product ID.
         * @param {string} [ideaPortalId] Filter ideas by idea portal ID.
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {number} [page] Page number for pagination.
         * @param {number} [perPage] Number of ideas per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasList: async (q?: string, updatedSince?: string, assignedToUser?: string, status?: string, category?: string, productId?: string, ideaPortalId?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListSortEnum, createdBefore?: string, createdSince?: string, tag?: string, userId?: string, ideaUserId?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ideas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (ideaPortalId !== undefined) {
                localVarQueryParameter['idea_portal_id'] = ideaPortalId;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }

            if (workflowStatus !== undefined) {
                localVarQueryParameter['workflow_status'] = workflowStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (ideaUserId !== undefined) {
                localVarQueryParameter['idea_user_id'] = ideaUserId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasMarkSpam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasMarkSpam', 'id', id)
            const localVarPath = `/ideas/{id}/spam`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaPromoteRequest} ideaPromoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasPromote: async (id: string, ideaPromoteRequest: IdeaPromoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasPromote', 'id', id)
            // verify required parameter 'ideaPromoteRequest' is not null or undefined
            assertParamExists('ideasPromote', 'ideaPromoteRequest', ideaPromoteRequest)
            const localVarPath = `/ideas/{id}/promote`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaPromoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUnmarkSpam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUnmarkSpam', 'id', id)
            const localVarPath = `/ideas/{id}/spam`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaUpdateRequest} ideaUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdate: async (id: string, ideaUpdateRequest: IdeaUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUpdate', 'id', id)
            // verify required parameter 'ideaUpdateRequest' is not null or undefined
            assertParamExists('ideasUpdate', 'ideaUpdateRequest', ideaUpdateRequest)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaWatchersRequest} ideaWatchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdateWatchers: async (id: string, ideaWatchersRequest: IdeaWatchersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUpdateWatchers', 'id', id)
            // verify required parameter 'ideaWatchersRequest' is not null or undefined
            assertParamExists('ideasUpdateWatchers', 'ideaWatchersRequest', ideaWatchersRequest)
            const localVarPath = `/ideas/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaWatchersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaVoteRequest} ideaVoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasVote: async (id: string, ideaVoteRequest: IdeaVoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasVote', 'id', id)
            // verify required parameter 'ideaVoteRequest' is not null or undefined
            assertParamExists('ideasVote', 'ideaVoteRequest', ideaVoteRequest)
            const localVarPath = `/ideas/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaVoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against the idea name
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {ProductsProductIdIdeasGetSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasGet: async (productId: string, q?: string, spam?: boolean, workflowStatus?: string, sort?: ProductsProductIdIdeasGetSortEnum, createdBefore?: string, createdSince?: string, updatedSince?: string, tag?: string, userId?: string, ideaUserId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productsProductIdIdeasGet', 'productId', productId)
            const localVarPath = `/products/{product_id}/ideas`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }

            if (workflowStatus !== undefined) {
                localVarQueryParameter['workflow_status'] = workflowStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (ideaUserId !== undefined) {
                localVarQueryParameter['idea_user_id'] = ideaUserId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateByPortalUserRequest} ideaCreateByPortalUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasPortalUserPost: async (productId: string, ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productsProductIdIdeasPortalUserPost', 'productId', productId)
            // verify required parameter 'ideaCreateByPortalUserRequest' is not null or undefined
            assertParamExists('productsProductIdIdeasPortalUserPost', 'ideaCreateByPortalUserRequest', ideaCreateByPortalUserRequest)
            const localVarPath = `/products/{product_id}/ideas/portal_user`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateByPortalUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasWithCategoryPost: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productsProductIdIdeasWithCategoryPost', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('productsProductIdIdeasWithCategoryPost', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas/with_category`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasWithScorePost: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productsProductIdIdeasWithScorePost', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('productsProductIdIdeasWithScorePost', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas/with_score`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdeasApi - functional programming interface
 * @export
 */
export const IdeasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdeasApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreate(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreate(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaEndorsementRequest} ideaEndorsementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateEndorsement(id: string, ideaEndorsementRequest: IdeaEndorsementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasCreateEndorsement201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateEndorsement(id, ideaEndorsementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateEndorsement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of endorsements per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetEndorsements(id: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetEndorsements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetEndorsements(id, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetEndorsements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of votes per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetVotes(id: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetVotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetVotes(id, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetVotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetWatchers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetWatchers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetWatchers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetWatchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasIdeaIdCommentsGet(ideaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpicsEpicIdCommentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasIdeaIdCommentsGet(ideaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasIdeaIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {string} [q] Search term to match against idea name.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
         * @param {string} [assignedToUser] ID or email address of a user. If provided, returns only ideas assigned to that user.
         * @param {string} [status] Status filter for ideas.
         * @param {string} [category] Filter ideas by category.
         * @param {string} [productId] Filter ideas by product ID.
         * @param {string} [ideaPortalId] Filter ideas by idea portal ID.
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {number} [page] Page number for pagination.
         * @param {number} [perPage] Number of ideas per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasList(q?: string, updatedSince?: string, assignedToUser?: string, status?: string, category?: string, productId?: string, ideaPortalId?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListSortEnum, createdBefore?: string, createdSince?: string, tag?: string, userId?: string, ideaUserId?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasList(q, updatedSince, assignedToUser, status, category, productId, ideaPortalId, spam, workflowStatus, sort, createdBefore, createdSince, tag, userId, ideaUserId, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasMarkSpam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasMarkSpam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasMarkSpam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaPromoteRequest} ideaPromoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasPromote(id: string, ideaPromoteRequest: IdeaPromoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasPromote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasPromote(id, ideaPromoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasPromote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUnmarkSpam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUnmarkSpam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUnmarkSpam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaUpdateRequest} ideaUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUpdate(id: string, ideaUpdateRequest: IdeaUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUpdate(id, ideaUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaWatchersRequest} ideaWatchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUpdateWatchers(id: string, ideaWatchersRequest: IdeaWatchersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUpdateWatchers(id, ideaWatchersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUpdateWatchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaVoteRequest} ideaVoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasVote(id: string, ideaVoteRequest: IdeaVoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasVote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasVote(id, ideaVoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against the idea name
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {ProductsProductIdIdeasGetSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsProductIdIdeasGet(productId: string, q?: string, spam?: boolean, workflowStatus?: string, sort?: ProductsProductIdIdeasGetSortEnum, createdBefore?: string, createdSince?: string, updatedSince?: string, tag?: string, userId?: string, ideaUserId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsProductIdIdeasGet(productId, q, spam, workflowStatus, sort, createdBefore, createdSince, updatedSince, tag, userId, ideaUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.productsProductIdIdeasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateByPortalUserRequest} ideaCreateByPortalUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsProductIdIdeasPortalUserPost(productId: string, ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsProductIdIdeasPortalUserPost(productId, ideaCreateByPortalUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.productsProductIdIdeasPortalUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsProductIdIdeasWithCategoryPost(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsProductIdIdeasWithCategoryPost(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.productsProductIdIdeasWithCategoryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsProductIdIdeasWithScorePost(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsProductIdIdeasWithScorePost(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.productsProductIdIdeasWithScorePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdeasApi - factory interface
 * @export
 */
export const IdeasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdeasApiFp(configuration)
    return {
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreate(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasCreateEndorsement201Response> {
            return localVarFp.ideasCreateEndorsement(requestParameters.id, requestParameters.ideaEndorsementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideasDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasGetById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetEndorsements200Response> {
            return localVarFp.ideasGetEndorsements(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetVotes200Response> {
            return localVarFp.ideasGetVotes(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetWatchers200Response> {
            return localVarFp.ideasGetWatchers(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {IdeasApiIdeasIdeaIdCommentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasIdeaIdCommentsGet(requestParameters: IdeasApiIdeasIdeaIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsEpicIdCommentsGet200Response> {
            return localVarFp.ideasIdeaIdCommentsGet(requestParameters.ideaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasList(requestParameters: IdeasApiIdeasListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse> {
            return localVarFp.ideasList(requestParameters.q, requestParameters.updatedSince, requestParameters.assignedToUser, requestParameters.status, requestParameters.category, requestParameters.productId, requestParameters.ideaPortalId, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasMarkSpam(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasPromote200Response> {
            return localVarFp.ideasPromote(requestParameters.id, requestParameters.ideaPromoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUnmarkSpam(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUpdate(requestParameters.id, requestParameters.ideaUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUpdateWatchers(requestParameters.id, requestParameters.ideaWatchersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasVote200Response> {
            return localVarFp.ideasVote(requestParameters.id, requestParameters.ideaVoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {IdeasApiProductsProductIdIdeasGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasGet(requestParameters: IdeasApiProductsProductIdIdeasGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse> {
            return localVarFp.productsProductIdIdeasGet(requestParameters.productId, requestParameters.q, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {IdeasApiProductsProductIdIdeasPortalUserPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasPortalUserPost(requestParameters: IdeasApiProductsProductIdIdeasPortalUserPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.productsProductIdIdeasPortalUserPost(requestParameters.productId, requestParameters.ideaCreateByPortalUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {IdeasApiProductsProductIdIdeasWithCategoryPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasWithCategoryPost(requestParameters: IdeasApiProductsProductIdIdeasWithCategoryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.productsProductIdIdeasWithCategoryPost(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {IdeasApiProductsProductIdIdeasWithScorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsProductIdIdeasWithScorePost(requestParameters: IdeasApiProductsProductIdIdeasWithScorePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.productsProductIdIdeasWithScorePost(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdeasApi - interface
 * @export
 * @interface IdeasApi
 */
export interface IdeasApiInterface {
    /**
     * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea
     * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates an endorsement (proxy vote) on an idea on behalf of another user.
     * @summary Create an endorsement (proxy vote)
     * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasCreateEndorsement201Response>;

    /**
     * Deletes the specified idea.
     * @summary Delete an idea
     * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of a specific idea.
     * @summary Get a specific idea
     * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Retrieves all endorsements for a specific idea.
     * @summary Get endorsements for an idea
     * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetEndorsements200Response>;

    /**
     * Retrieves all votes for a specific idea.
     * @summary Get votes for an idea
     * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetVotes200Response>;

    /**
     * Retrieves the watchers for an idea.
     * @summary Get idea watchers
     * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetWatchers200Response>;

    /**
     * Retrieves a list of comments associated with the specified idea.
     * @summary List comments on an idea
     * @param {IdeasApiIdeasIdeaIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasIdeaIdCommentsGet(requestParameters: IdeasApiIdeasIdeaIdCommentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsEpicIdCommentsGet200Response>;

    /**
     * Retrieves a list of all ideas in the account.
     * @summary List ideas
     * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasList(requestParameters?: IdeasApiIdeasListRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse>;

    /**
     * Marks an idea as spam.
     * @summary Mark idea as spam
     * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Promotes an idea to a feature, epic, or initiative.
     * @summary Promote an idea
     * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasPromote200Response>;

    /**
     * Removes the spam flag from an idea.
     * @summary Unmark idea as spam
     * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Updates the details of a specific idea.
     * @summary Update an idea
     * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Updates the watchers for an idea.
     * @summary Update idea watchers
     * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Adds a vote to an idea.
     * @summary Vote on an idea
     * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasVote200Response>;

    /**
     * Retrieves a list of ideas for the specified product.
     * @summary List ideas for a product
     * @param {IdeasApiProductsProductIdIdeasGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    productsProductIdIdeasGet(requestParameters: IdeasApiProductsProductIdIdeasGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse>;

    /**
     * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea created by a ideas portal user
     * @param {IdeasApiProductsProductIdIdeasPortalUserPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    productsProductIdIdeasPortalUserPost(requestParameters: IdeasApiProductsProductIdIdeasPortalUserPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a category
     * @param {IdeasApiProductsProductIdIdeasWithCategoryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    productsProductIdIdeasWithCategoryPost(requestParameters: IdeasApiProductsProductIdIdeasWithCategoryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a score
     * @param {IdeasApiProductsProductIdIdeasWithScorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    productsProductIdIdeasWithScorePost(requestParameters: IdeasApiProductsProductIdIdeasWithScorePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

}

/**
 * Request parameters for ideasCreate operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateRequest
 */
export interface IdeasApiIdeasCreateRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiIdeasCreate
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateRequest}
     * @memberof IdeasApiIdeasCreate
     */
    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasCreateEndorsement operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateEndorsementRequest
 */
export interface IdeasApiIdeasCreateEndorsementRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasCreateEndorsement
     */
    readonly id: string

    /**
     * 
     * @type {IdeaEndorsementRequest}
     * @memberof IdeasApiIdeasCreateEndorsement
     */
    readonly ideaEndorsementRequest: IdeaEndorsementRequest
}

/**
 * Request parameters for ideasDelete operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasDeleteRequest
 */
export interface IdeasApiIdeasDeleteRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasDelete
     */
    readonly id: string
}

/**
 * Request parameters for ideasGetById operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetByIdRequest
 */
export interface IdeasApiIdeasGetByIdRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetById
     */
    readonly id: string
}

/**
 * Request parameters for ideasGetEndorsements operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetEndorsementsRequest
 */
export interface IdeasApiIdeasGetEndorsementsRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly id: string

    /**
     * Page number for pagination
     * @type {number}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly page?: number

    /**
     * Number of endorsements per page
     * @type {number}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasGetVotes operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetVotesRequest
 */
export interface IdeasApiIdeasGetVotesRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetVotes
     */
    readonly id: string

    /**
     * Page number for pagination
     * @type {number}
     * @memberof IdeasApiIdeasGetVotes
     */
    readonly page?: number

    /**
     * Number of votes per page
     * @type {number}
     * @memberof IdeasApiIdeasGetVotes
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasGetWatchers operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetWatchersRequest
 */
export interface IdeasApiIdeasGetWatchersRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetWatchers
     */
    readonly id: string
}

/**
 * Request parameters for ideasIdeaIdCommentsGet operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasIdeaIdCommentsGetRequest
 */
export interface IdeasApiIdeasIdeaIdCommentsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof IdeasApiIdeasIdeaIdCommentsGet
     */
    readonly ideaId: string
}

/**
 * Request parameters for ideasList operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasListRequest
 */
export interface IdeasApiIdeasListRequest {
    /**
     * Search term to match against idea name.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly q?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly updatedSince?: string

    /**
     * ID or email address of a user. If provided, returns only ideas assigned to that user.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly assignedToUser?: string

    /**
     * Status filter for ideas.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly status?: string

    /**
     * Filter ideas by category.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly category?: string

    /**
     * Filter ideas by product ID.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly productId?: string

    /**
     * Filter ideas by idea portal ID.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly ideaPortalId?: string

    /**
     * When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
     * @type {boolean}
     * @memberof IdeasApiIdeasList
     */
    readonly spam?: boolean

    /**
     * When present, filters to ideas with the provided workflow status ID or name.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly workflowStatus?: string

    /**
     * Sorting of the list of ideas. Accepted values are recent, trending, or popular.
     * @type {'recent' | 'trending' | 'popular'}
     * @memberof IdeasApiIdeasList
     */
    readonly sort?: IdeasListSortEnum

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly createdBefore?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly createdSince?: string

    /**
     * String tag value. If provided, only ideas with the associated tag will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly tag?: string

    /**
     * ID of a user. If provided, only ideas created by that user will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly userId?: string

    /**
     * ID of an idea user. If provided, only ideas created by that idea user will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly ideaUserId?: string

    /**
     * Page number for pagination.
     * @type {number}
     * @memberof IdeasApiIdeasList
     */
    readonly page?: number

    /**
     * Number of ideas per page.
     * @type {number}
     * @memberof IdeasApiIdeasList
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasMarkSpam operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasMarkSpamRequest
 */
export interface IdeasApiIdeasMarkSpamRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasMarkSpam
     */
    readonly id: string
}

/**
 * Request parameters for ideasPromote operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasPromoteRequest
 */
export interface IdeasApiIdeasPromoteRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasPromote
     */
    readonly id: string

    /**
     * 
     * @type {IdeaPromoteRequest}
     * @memberof IdeasApiIdeasPromote
     */
    readonly ideaPromoteRequest: IdeaPromoteRequest
}

/**
 * Request parameters for ideasUnmarkSpam operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasUnmarkSpamRequest
 */
export interface IdeasApiIdeasUnmarkSpamRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasUnmarkSpam
     */
    readonly id: string
}

/**
 * Request parameters for ideasUpdate operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasUpdateRequest
 */
export interface IdeasApiIdeasUpdateRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasUpdate
     */
    readonly id: string

    /**
     * 
     * @type {IdeaUpdateRequest}
     * @memberof IdeasApiIdeasUpdate
     */
    readonly ideaUpdateRequest: IdeaUpdateRequest
}

/**
 * Request parameters for ideasUpdateWatchers operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasUpdateWatchersRequest
 */
export interface IdeasApiIdeasUpdateWatchersRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasUpdateWatchers
     */
    readonly id: string

    /**
     * 
     * @type {IdeaWatchersRequest}
     * @memberof IdeasApiIdeasUpdateWatchers
     */
    readonly ideaWatchersRequest: IdeaWatchersRequest
}

/**
 * Request parameters for ideasVote operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasVoteRequest
 */
export interface IdeasApiIdeasVoteRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasVote
     */
    readonly id: string

    /**
     * 
     * @type {IdeaVoteRequest}
     * @memberof IdeasApiIdeasVote
     */
    readonly ideaVoteRequest: IdeaVoteRequest
}

/**
 * Request parameters for productsProductIdIdeasGet operation in IdeasApi.
 * @export
 * @interface IdeasApiProductsProductIdIdeasGetRequest
 */
export interface IdeasApiProductsProductIdIdeasGetRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly productId: string

    /**
     * Search term to match against the idea name
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly q?: string

    /**
     * When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
     * @type {boolean}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly spam?: boolean

    /**
     * When present, filters to ideas with the provided workflow status ID or name.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly workflowStatus?: string

    /**
     * Sorting of the list of ideas. Accepted values are recent, trending, or popular.
     * @type {'recent' | 'trending' | 'popular'}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly sort?: ProductsProductIdIdeasGetSortEnum

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly createdBefore?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly createdSince?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly updatedSince?: string

    /**
     * String tag value. If provided, only ideas with the associated tag will be returned.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly tag?: string

    /**
     * ID of a user. If provided, only ideas created by that user will be returned.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly userId?: string

    /**
     * ID of an idea user. If provided, only ideas created by that idea user will be returned.
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasGet
     */
    readonly ideaUserId?: string
}

/**
 * Request parameters for productsProductIdIdeasPortalUserPost operation in IdeasApi.
 * @export
 * @interface IdeasApiProductsProductIdIdeasPortalUserPostRequest
 */
export interface IdeasApiProductsProductIdIdeasPortalUserPostRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasPortalUserPost
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateByPortalUserRequest}
     * @memberof IdeasApiProductsProductIdIdeasPortalUserPost
     */
    readonly ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest
}

/**
 * Request parameters for productsProductIdIdeasWithCategoryPost operation in IdeasApi.
 * @export
 * @interface IdeasApiProductsProductIdIdeasWithCategoryPostRequest
 */
export interface IdeasApiProductsProductIdIdeasWithCategoryPostRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasWithCategoryPost
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateRequest}
     * @memberof IdeasApiProductsProductIdIdeasWithCategoryPost
     */
    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for productsProductIdIdeasWithScorePost operation in IdeasApi.
 * @export
 * @interface IdeasApiProductsProductIdIdeasWithScorePostRequest
 */
export interface IdeasApiProductsProductIdIdeasWithScorePostRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiProductsProductIdIdeasWithScorePost
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateRequest}
     * @memberof IdeasApiProductsProductIdIdeasWithScorePost
     */
    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * IdeasApi - object-oriented interface
 * @export
 * @class IdeasApi
 * @extends {BaseAPI}
 */
export class IdeasApi extends BaseAPI implements IdeasApiInterface {
    /**
     * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea
     * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreate(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an endorsement (proxy vote) on an idea on behalf of another user.
     * @summary Create an endorsement (proxy vote)
     * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateEndorsement(requestParameters.id, requestParameters.ideaEndorsementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified idea.
     * @summary Delete an idea
     * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specific idea.
     * @summary Get a specific idea
     * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all endorsements for a specific idea.
     * @summary Get endorsements for an idea
     * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetEndorsements(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all votes for a specific idea.
     * @summary Get votes for an idea
     * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetVotes(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the watchers for an idea.
     * @summary Get idea watchers
     * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetWatchers(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of comments associated with the specified idea.
     * @summary List comments on an idea
     * @param {IdeasApiIdeasIdeaIdCommentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasIdeaIdCommentsGet(requestParameters: IdeasApiIdeasIdeaIdCommentsGetRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasIdeaIdCommentsGet(requestParameters.ideaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all ideas in the account.
     * @summary List ideas
     * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasList(requestParameters: IdeasApiIdeasListRequest = {}, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasList(requestParameters.q, requestParameters.updatedSince, requestParameters.assignedToUser, requestParameters.status, requestParameters.category, requestParameters.productId, requestParameters.ideaPortalId, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an idea as spam.
     * @summary Mark idea as spam
     * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasMarkSpam(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Promotes an idea to a feature, epic, or initiative.
     * @summary Promote an idea
     * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasPromote(requestParameters.id, requestParameters.ideaPromoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the spam flag from an idea.
     * @summary Unmark idea as spam
     * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUnmarkSpam(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of a specific idea.
     * @summary Update an idea
     * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUpdate(requestParameters.id, requestParameters.ideaUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the watchers for an idea.
     * @summary Update idea watchers
     * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUpdateWatchers(requestParameters.id, requestParameters.ideaWatchersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a vote to an idea.
     * @summary Vote on an idea
     * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasVote(requestParameters.id, requestParameters.ideaVoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of ideas for the specified product.
     * @summary List ideas for a product
     * @param {IdeasApiProductsProductIdIdeasGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public productsProductIdIdeasGet(requestParameters: IdeasApiProductsProductIdIdeasGetRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).productsProductIdIdeasGet(requestParameters.productId, requestParameters.q, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea created by a ideas portal user
     * @param {IdeasApiProductsProductIdIdeasPortalUserPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public productsProductIdIdeasPortalUserPost(requestParameters: IdeasApiProductsProductIdIdeasPortalUserPostRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).productsProductIdIdeasPortalUserPost(requestParameters.productId, requestParameters.ideaCreateByPortalUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a category
     * @param {IdeasApiProductsProductIdIdeasWithCategoryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public productsProductIdIdeasWithCategoryPost(requestParameters: IdeasApiProductsProductIdIdeasWithCategoryPostRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).productsProductIdIdeasWithCategoryPost(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a score
     * @param {IdeasApiProductsProductIdIdeasWithScorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public productsProductIdIdeasWithScorePost(requestParameters: IdeasApiProductsProductIdIdeasWithScorePostRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).productsProductIdIdeasWithScorePost(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const IdeasListSortEnum = {
    RECENT: 'recent',
    TRENDING: 'trending',
    POPULAR: 'popular'
} as const;
export type IdeasListSortEnum = typeof IdeasListSortEnum[keyof typeof IdeasListSortEnum];
/**
 * @export
 */
export const ProductsProductIdIdeasGetSortEnum = {
    RECENT: 'recent',
    TRENDING: 'trending',
    POPULAR: 'popular'
} as const;
export type ProductsProductIdIdeasGetSortEnum = typeof ProductsProductIdIdeasGetSortEnum[keyof typeof ProductsProductIdIdeasGetSortEnum];
