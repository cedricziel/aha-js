/* tslint:disable */
/* eslint-disable */
/**
 * Aha! REST API
 * API for interacting with Aha! product management platform.  ## Rate Limiting The API enforces rate limits to ensure fair usage: - **300 requests per minute** per account - **20 requests per second** per account  When rate limits are exceeded, the API returns a `429 Too Many Requests` response with a `retry_after` header indicating when to retry.  ## Authentication The API supports two authentication methods: - **OAuth 2.0**: For web applications and integrations requiring user consent - **API Tokens**: For server-to-server integrations and personal access  ## Request Headers - **User-Agent**: Required header to identify the client application - **Content-Type**: Set to `application/json` for POST/PUT requests - **Authorization**: Bearer token or OAuth access token  ## Response Format All responses are in JSON format. List endpoints include pagination metadata in the `meta.pagination` object.  ## Error Handling The API uses standard HTTP status codes and includes detailed error messages in the response body for debugging. 
 *
 * The version of the OpenAPI document: 1.0.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Comment } from '../model';
// @ts-ignore
import type { CommentCreateRequest } from '../model';
// @ts-ignore
import type { CommentsGetEpic200Response } from '../model';
// @ts-ignore
import type { IdeaCreateByPortalUserRequest } from '../model';
// @ts-ignore
import type { IdeaCreateRequest } from '../model';
// @ts-ignore
import type { IdeaEndorsementRequest } from '../model';
// @ts-ignore
import type { IdeaPromoteRequest } from '../model';
// @ts-ignore
import type { IdeaResponse } from '../model';
// @ts-ignore
import type { IdeaUpdateRequest } from '../model';
// @ts-ignore
import type { IdeaVoteRequest } from '../model';
// @ts-ignore
import type { IdeaWatchersRequest } from '../model';
// @ts-ignore
import type { IdeasCreateEndorsement201Response } from '../model';
// @ts-ignore
import type { IdeasGetEndorsements200Response } from '../model';
// @ts-ignore
import type { IdeasGetVotes200Response } from '../model';
// @ts-ignore
import type { IdeasGetWatchers200Response } from '../model';
// @ts-ignore
import type { IdeasListResponse } from '../model';
// @ts-ignore
import type { IdeasPromote200Response } from '../model';
// @ts-ignore
import type { IdeasVote200Response } from '../model';
/**
 * IdeasApi - axios parameter creator
 */
export const IdeasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new comment to the specified idea.
         * @summary Create a comment on an idea
         * @param {string} ideaId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreateIdea: async (ideaId: string, commentCreateRequest: CommentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('commentsCreateIdea', 'ideaId', ideaId)
            // verify required parameter 'commentCreateRequest' is not null or undefined
            assertParamExists('commentsCreateIdea', 'commentCreateRequest', commentCreateRequest)
            const localVarPath = `/ideas/{idea_id}/comments`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetIdea: async (ideaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('commentsGetIdea', 'ideaId', ideaId)
            const localVarPath = `/ideas/{idea_id}/comments`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreate: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreate', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreate', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateByPortalUserRequest} ideaCreateByPortalUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateByPortalUser: async (productId: string, ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreateByPortalUser', 'productId', productId)
            // verify required parameter 'ideaCreateByPortalUserRequest' is not null or undefined
            assertParamExists('ideasCreateByPortalUser', 'ideaCreateByPortalUserRequest', ideaCreateByPortalUserRequest)
            const localVarPath = `/products/{product_id}/ideas/portal_user`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateByPortalUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaEndorsementRequest} ideaEndorsementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateEndorsement: async (id: string, ideaEndorsementRequest: IdeaEndorsementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasCreateEndorsement', 'id', id)
            // verify required parameter 'ideaEndorsementRequest' is not null or undefined
            assertParamExists('ideasCreateEndorsement', 'ideaEndorsementRequest', ideaEndorsementRequest)
            const localVarPath = `/ideas/{id}/endorsements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaEndorsementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithCategory: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreateWithCategory', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreateWithCategory', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas/with_category`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithScore: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreateWithScore', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreateWithScore', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas/with_score`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasDelete', 'id', id)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetById', 'id', id)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {boolean} [proxy] If set to true, only returns proxy votes (votes with an associated organization)
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of endorsements per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetEndorsements: async (id: string, proxy?: boolean, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetEndorsements', 'id', id)
            const localVarPath = `/ideas/{id}/endorsements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (proxy !== undefined) {
                localVarQueryParameter['proxy'] = proxy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of votes per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetVotes: async (id: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetVotes', 'id', id)
            const localVarPath = `/ideas/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetWatchers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetWatchers', 'id', id)
            const localVarPath = `/ideas/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (max 200)
         * @param {string} [fields] Comma-separated list of fields to include in response for customization
         * @param {string} [q] Search term to match against idea name.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
         * @param {string} [assignedToUser] ID or email address of a user. If provided, returns only ideas assigned to that user.
         * @param {string} [status] Status filter for ideas.
         * @param {string} [category] Filter ideas by category.
         * @param {string} [productId] Filter ideas by product ID.
         * @param {string} [ideaPortalId] Filter ideas by idea portal ID.
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasList: async (page?: number, perPage?: number, fields?: string, q?: string, updatedSince?: string, assignedToUser?: string, status?: string, category?: string, productId?: string, ideaPortalId?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListSortEnum, createdBefore?: string, createdSince?: string, tag?: string, userId?: string, ideaUserId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ideas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (ideaPortalId !== undefined) {
                localVarQueryParameter['idea_portal_id'] = ideaPortalId;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }

            if (workflowStatus !== undefined) {
                localVarQueryParameter['workflow_status'] = workflowStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (ideaUserId !== undefined) {
                localVarQueryParameter['idea_user_id'] = ideaUserId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against the idea name
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListProductSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasListProduct: async (productId: string, q?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListProductSortEnum, createdBefore?: string, createdSince?: string, updatedSince?: string, tag?: string, userId?: string, ideaUserId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasListProduct', 'productId', productId)
            const localVarPath = `/products/{product_id}/ideas`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }

            if (workflowStatus !== undefined) {
                localVarQueryParameter['workflow_status'] = workflowStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (ideaUserId !== undefined) {
                localVarQueryParameter['idea_user_id'] = ideaUserId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasMarkSpam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasMarkSpam', 'id', id)
            const localVarPath = `/ideas/{id}/spam`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaPromoteRequest} ideaPromoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasPromote: async (id: string, ideaPromoteRequest: IdeaPromoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasPromote', 'id', id)
            // verify required parameter 'ideaPromoteRequest' is not null or undefined
            assertParamExists('ideasPromote', 'ideaPromoteRequest', ideaPromoteRequest)
            const localVarPath = `/ideas/{id}/promote`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaPromoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUnmarkSpam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUnmarkSpam', 'id', id)
            const localVarPath = `/ideas/{id}/spam`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaUpdateRequest} ideaUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdate: async (id: string, ideaUpdateRequest: IdeaUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUpdate', 'id', id)
            // verify required parameter 'ideaUpdateRequest' is not null or undefined
            assertParamExists('ideasUpdate', 'ideaUpdateRequest', ideaUpdateRequest)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaWatchersRequest} ideaWatchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdateWatchers: async (id: string, ideaWatchersRequest: IdeaWatchersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUpdateWatchers', 'id', id)
            // verify required parameter 'ideaWatchersRequest' is not null or undefined
            assertParamExists('ideasUpdateWatchers', 'ideaWatchersRequest', ideaWatchersRequest)
            const localVarPath = `/ideas/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaWatchersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaVoteRequest} ideaVoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasVote: async (id: string, ideaVoteRequest: IdeaVoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasVote', 'id', id)
            // verify required parameter 'ideaVoteRequest' is not null or undefined
            assertParamExists('ideasVote', 'ideaVoteRequest', ideaVoteRequest)
            const localVarPath = `/ideas/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaVoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdeasApi - functional programming interface
 */
export const IdeasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdeasApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new comment to the specified idea.
         * @summary Create a comment on an idea
         * @param {string} ideaId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsCreateIdea(ideaId: string, commentCreateRequest: CommentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsCreateIdea(ideaId, commentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.commentsCreateIdea']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsGetIdea(ideaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentsGetEpic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsGetIdea(ideaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.commentsGetIdea']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreate(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreate(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateByPortalUserRequest} ideaCreateByPortalUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateByPortalUser(productId: string, ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateByPortalUser(productId, ideaCreateByPortalUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateByPortalUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaEndorsementRequest} ideaEndorsementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateEndorsement(id: string, ideaEndorsementRequest: IdeaEndorsementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasCreateEndorsement201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateEndorsement(id, ideaEndorsementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateEndorsement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateWithCategory(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateWithCategory(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateWithCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateWithScore(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateWithScore(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateWithScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {boolean} [proxy] If set to true, only returns proxy votes (votes with an associated organization)
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of endorsements per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetEndorsements(id: string, proxy?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetEndorsements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetEndorsements(id, proxy, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetEndorsements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of votes per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetVotes(id: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetVotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetVotes(id, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetVotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetWatchers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetWatchers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetWatchers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetWatchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (max 200)
         * @param {string} [fields] Comma-separated list of fields to include in response for customization
         * @param {string} [q] Search term to match against idea name.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
         * @param {string} [assignedToUser] ID or email address of a user. If provided, returns only ideas assigned to that user.
         * @param {string} [status] Status filter for ideas.
         * @param {string} [category] Filter ideas by category.
         * @param {string} [productId] Filter ideas by product ID.
         * @param {string} [ideaPortalId] Filter ideas by idea portal ID.
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasList(page?: number, perPage?: number, fields?: string, q?: string, updatedSince?: string, assignedToUser?: string, status?: string, category?: string, productId?: string, ideaPortalId?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListSortEnum, createdBefore?: string, createdSince?: string, tag?: string, userId?: string, ideaUserId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasList(page, perPage, fields, q, updatedSince, assignedToUser, status, category, productId, ideaPortalId, spam, workflowStatus, sort, createdBefore, createdSince, tag, userId, ideaUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against the idea name
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListProductSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasListProduct(productId: string, q?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListProductSortEnum, createdBefore?: string, createdSince?: string, updatedSince?: string, tag?: string, userId?: string, ideaUserId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasListProduct(productId, q, spam, workflowStatus, sort, createdBefore, createdSince, updatedSince, tag, userId, ideaUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasListProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasMarkSpam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasMarkSpam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasMarkSpam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaPromoteRequest} ideaPromoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasPromote(id: string, ideaPromoteRequest: IdeaPromoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasPromote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasPromote(id, ideaPromoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasPromote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUnmarkSpam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUnmarkSpam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUnmarkSpam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaUpdateRequest} ideaUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUpdate(id: string, ideaUpdateRequest: IdeaUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUpdate(id, ideaUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaWatchersRequest} ideaWatchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUpdateWatchers(id: string, ideaWatchersRequest: IdeaWatchersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUpdateWatchers(id, ideaWatchersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUpdateWatchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaVoteRequest} ideaVoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasVote(id: string, ideaVoteRequest: IdeaVoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasVote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasVote(id, ideaVoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdeasApi - factory interface
 */
export const IdeasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdeasApiFp(configuration)
    return {
        /**
         * Adds a new comment to the specified idea.
         * @summary Create a comment on an idea
         * @param {IdeasApiCommentsCreateIdeaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreateIdea(requestParameters: IdeasApiCommentsCreateIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.commentsCreateIdea(requestParameters.ideaId, requestParameters.commentCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {IdeasApiCommentsGetIdeaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetIdea(requestParameters: IdeasApiCommentsGetIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentsGetEpic200Response> {
            return localVarFp.commentsGetIdea(requestParameters.ideaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreate(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {IdeasApiIdeasCreateByPortalUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateByPortalUser(requestParameters: IdeasApiIdeasCreateByPortalUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreateByPortalUser(requestParameters.productId, requestParameters.ideaCreateByPortalUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasCreateEndorsement201Response> {
            return localVarFp.ideasCreateEndorsement(requestParameters.id, requestParameters.ideaEndorsementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {IdeasApiIdeasCreateWithCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithCategory(requestParameters: IdeasApiIdeasCreateWithCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreateWithCategory(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {IdeasApiIdeasCreateWithScoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithScore(requestParameters: IdeasApiIdeasCreateWithScoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreateWithScore(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideasDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasGetById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetEndorsements200Response> {
            return localVarFp.ideasGetEndorsements(requestParameters.id, requestParameters.proxy, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetVotes200Response> {
            return localVarFp.ideasGetVotes(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetWatchers200Response> {
            return localVarFp.ideasGetWatchers(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasList(requestParameters: IdeasApiIdeasListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse> {
            return localVarFp.ideasList(requestParameters.page, requestParameters.perPage, requestParameters.fields, requestParameters.q, requestParameters.updatedSince, requestParameters.assignedToUser, requestParameters.status, requestParameters.category, requestParameters.productId, requestParameters.ideaPortalId, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {IdeasApiIdeasListProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasListProduct(requestParameters: IdeasApiIdeasListProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse> {
            return localVarFp.ideasListProduct(requestParameters.productId, requestParameters.q, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasMarkSpam(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasPromote200Response> {
            return localVarFp.ideasPromote(requestParameters.id, requestParameters.ideaPromoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUnmarkSpam(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUpdate(requestParameters.id, requestParameters.ideaUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUpdateWatchers(requestParameters.id, requestParameters.ideaWatchersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasVote200Response> {
            return localVarFp.ideasVote(requestParameters.id, requestParameters.ideaVoteRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdeasApi - interface
 */
export interface IdeasApiInterface {
    /**
     * Adds a new comment to the specified idea.
     * @summary Create a comment on an idea
     * @param {IdeasApiCommentsCreateIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commentsCreateIdea(requestParameters: IdeasApiCommentsCreateIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * Retrieves a list of comments associated with the specified idea.
     * @summary List comments on an idea
     * @param {IdeasApiCommentsGetIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commentsGetIdea(requestParameters: IdeasApiCommentsGetIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentsGetEpic200Response>;

    /**
     * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea
     * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea created by a ideas portal user
     * @param {IdeasApiIdeasCreateByPortalUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasCreateByPortalUser(requestParameters: IdeasApiIdeasCreateByPortalUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates an endorsement (proxy vote) on an idea on behalf of another user.
     * @summary Create an endorsement (proxy vote)
     * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasCreateEndorsement201Response>;

    /**
     * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a category
     * @param {IdeasApiIdeasCreateWithCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasCreateWithCategory(requestParameters: IdeasApiIdeasCreateWithCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a score
     * @param {IdeasApiIdeasCreateWithScoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasCreateWithScore(requestParameters: IdeasApiIdeasCreateWithScoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Deletes the specified idea.
     * @summary Delete an idea
     * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of a specific idea.
     * @summary Get a specific idea
     * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Retrieves all endorsements for a specific idea.
     * @summary Get endorsements for an idea
     * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetEndorsements200Response>;

    /**
     * Retrieves all votes for a specific idea.
     * @summary Get votes for an idea
     * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetVotes200Response>;

    /**
     * Retrieves the watchers for an idea.
     * @summary Get idea watchers
     * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetWatchers200Response>;

    /**
     * Retrieves a list of all ideas in the account.
     * @summary List ideas
     * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasList(requestParameters?: IdeasApiIdeasListRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse>;

    /**
     * Retrieves a list of ideas for the specified product.
     * @summary List ideas for a product
     * @param {IdeasApiIdeasListProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasListProduct(requestParameters: IdeasApiIdeasListProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse>;

    /**
     * Marks an idea as spam.
     * @summary Mark idea as spam
     * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Promotes an idea to a feature, epic, or initiative.
     * @summary Promote an idea
     * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasPromote200Response>;

    /**
     * Removes the spam flag from an idea.
     * @summary Unmark idea as spam
     * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Updates the details of a specific idea.
     * @summary Update an idea
     * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Updates the watchers for an idea.
     * @summary Update idea watchers
     * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Adds a vote to an idea.
     * @summary Vote on an idea
     * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasVote200Response>;

}

/**
 * Request parameters for commentsCreateIdea operation in IdeasApi.
 */
export interface IdeasApiCommentsCreateIdeaRequest {
    readonly ideaId: string

    readonly commentCreateRequest: CommentCreateRequest
}

/**
 * Request parameters for commentsGetIdea operation in IdeasApi.
 */
export interface IdeasApiCommentsGetIdeaRequest {
    readonly ideaId: string
}

/**
 * Request parameters for ideasCreate operation in IdeasApi.
 */
export interface IdeasApiIdeasCreateRequest {
    /**
     * Numeric ID or key of the product
     */
    readonly productId: string

    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasCreateByPortalUser operation in IdeasApi.
 */
export interface IdeasApiIdeasCreateByPortalUserRequest {
    /**
     * Numeric ID or key of the product
     */
    readonly productId: string

    readonly ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest
}

/**
 * Request parameters for ideasCreateEndorsement operation in IdeasApi.
 */
export interface IdeasApiIdeasCreateEndorsementRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    readonly ideaEndorsementRequest: IdeaEndorsementRequest
}

/**
 * Request parameters for ideasCreateWithCategory operation in IdeasApi.
 */
export interface IdeasApiIdeasCreateWithCategoryRequest {
    /**
     * Numeric ID or key of the product
     */
    readonly productId: string

    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasCreateWithScore operation in IdeasApi.
 */
export interface IdeasApiIdeasCreateWithScoreRequest {
    /**
     * Numeric ID or key of the product
     */
    readonly productId: string

    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasDelete operation in IdeasApi.
 */
export interface IdeasApiIdeasDeleteRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string
}

/**
 * Request parameters for ideasGetById operation in IdeasApi.
 */
export interface IdeasApiIdeasGetByIdRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string
}

/**
 * Request parameters for ideasGetEndorsements operation in IdeasApi.
 */
export interface IdeasApiIdeasGetEndorsementsRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    /**
     * If set to true, only returns proxy votes (votes with an associated organization)
     */
    readonly proxy?: boolean

    /**
     * Page number for pagination
     */
    readonly page?: number

    /**
     * Number of endorsements per page
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasGetVotes operation in IdeasApi.
 */
export interface IdeasApiIdeasGetVotesRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    /**
     * Page number for pagination
     */
    readonly page?: number

    /**
     * Number of votes per page
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasGetWatchers operation in IdeasApi.
 */
export interface IdeasApiIdeasGetWatchersRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string
}

/**
 * Request parameters for ideasList operation in IdeasApi.
 */
export interface IdeasApiIdeasListRequest {
    /**
     * Page number for pagination (starts at 1)
     */
    readonly page?: number

    /**
     * Number of items per page (max 200)
     */
    readonly perPage?: number

    /**
     * Comma-separated list of fields to include in response for customization
     */
    readonly fields?: string

    /**
     * Search term to match against idea name.
     */
    readonly q?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
     */
    readonly updatedSince?: string

    /**
     * ID or email address of a user. If provided, returns only ideas assigned to that user.
     */
    readonly assignedToUser?: string

    /**
     * Status filter for ideas.
     */
    readonly status?: string

    /**
     * Filter ideas by category.
     */
    readonly category?: string

    /**
     * Filter ideas by product ID.
     */
    readonly productId?: string

    /**
     * Filter ideas by idea portal ID.
     */
    readonly ideaPortalId?: string

    /**
     * When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
     */
    readonly spam?: boolean

    /**
     * When present, filters to ideas with the provided workflow status ID or name.
     */
    readonly workflowStatus?: string

    /**
     * Sorting of the list of ideas. Accepted values are recent, trending, or popular.
     */
    readonly sort?: IdeasListSortEnum

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
     */
    readonly createdBefore?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
     */
    readonly createdSince?: string

    /**
     * String tag value. If provided, only ideas with the associated tag will be returned.
     */
    readonly tag?: string

    /**
     * ID of a user. If provided, only ideas created by that user will be returned.
     */
    readonly userId?: string

    /**
     * ID of an idea user. If provided, only ideas created by that idea user will be returned.
     */
    readonly ideaUserId?: string
}

/**
 * Request parameters for ideasListProduct operation in IdeasApi.
 */
export interface IdeasApiIdeasListProductRequest {
    /**
     * Numeric ID or key of the product
     */
    readonly productId: string

    /**
     * Search term to match against the idea name
     */
    readonly q?: string

    /**
     * When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
     */
    readonly spam?: boolean

    /**
     * When present, filters to ideas with the provided workflow status ID or name.
     */
    readonly workflowStatus?: string

    /**
     * Sorting of the list of ideas. Accepted values are recent, trending, or popular.
     */
    readonly sort?: IdeasListProductSortEnum

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
     */
    readonly createdBefore?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
     */
    readonly createdSince?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
     */
    readonly updatedSince?: string

    /**
     * String tag value. If provided, only ideas with the associated tag will be returned.
     */
    readonly tag?: string

    /**
     * ID of a user. If provided, only ideas created by that user will be returned.
     */
    readonly userId?: string

    /**
     * ID of an idea user. If provided, only ideas created by that idea user will be returned.
     */
    readonly ideaUserId?: string
}

/**
 * Request parameters for ideasMarkSpam operation in IdeasApi.
 */
export interface IdeasApiIdeasMarkSpamRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string
}

/**
 * Request parameters for ideasPromote operation in IdeasApi.
 */
export interface IdeasApiIdeasPromoteRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    readonly ideaPromoteRequest: IdeaPromoteRequest
}

/**
 * Request parameters for ideasUnmarkSpam operation in IdeasApi.
 */
export interface IdeasApiIdeasUnmarkSpamRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string
}

/**
 * Request parameters for ideasUpdate operation in IdeasApi.
 */
export interface IdeasApiIdeasUpdateRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    readonly ideaUpdateRequest: IdeaUpdateRequest
}

/**
 * Request parameters for ideasUpdateWatchers operation in IdeasApi.
 */
export interface IdeasApiIdeasUpdateWatchersRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    readonly ideaWatchersRequest: IdeaWatchersRequest
}

/**
 * Request parameters for ideasVote operation in IdeasApi.
 */
export interface IdeasApiIdeasVoteRequest {
    /**
     * Numeric ID or key of the idea
     */
    readonly id: string

    readonly ideaVoteRequest: IdeaVoteRequest
}

/**
 * IdeasApi - object-oriented interface
 */
export class IdeasApi extends BaseAPI implements IdeasApiInterface {
    /**
     * Adds a new comment to the specified idea.
     * @summary Create a comment on an idea
     * @param {IdeasApiCommentsCreateIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commentsCreateIdea(requestParameters: IdeasApiCommentsCreateIdeaRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).commentsCreateIdea(requestParameters.ideaId, requestParameters.commentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of comments associated with the specified idea.
     * @summary List comments on an idea
     * @param {IdeasApiCommentsGetIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commentsGetIdea(requestParameters: IdeasApiCommentsGetIdeaRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).commentsGetIdea(requestParameters.ideaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea
     * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreate(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea created by a ideas portal user
     * @param {IdeasApiIdeasCreateByPortalUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasCreateByPortalUser(requestParameters: IdeasApiIdeasCreateByPortalUserRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateByPortalUser(requestParameters.productId, requestParameters.ideaCreateByPortalUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an endorsement (proxy vote) on an idea on behalf of another user.
     * @summary Create an endorsement (proxy vote)
     * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateEndorsement(requestParameters.id, requestParameters.ideaEndorsementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a category
     * @param {IdeasApiIdeasCreateWithCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasCreateWithCategory(requestParameters: IdeasApiIdeasCreateWithCategoryRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateWithCategory(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a score
     * @param {IdeasApiIdeasCreateWithScoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasCreateWithScore(requestParameters: IdeasApiIdeasCreateWithScoreRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateWithScore(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified idea.
     * @summary Delete an idea
     * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specific idea.
     * @summary Get a specific idea
     * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all endorsements for a specific idea.
     * @summary Get endorsements for an idea
     * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetEndorsements(requestParameters.id, requestParameters.proxy, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all votes for a specific idea.
     * @summary Get votes for an idea
     * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetVotes(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the watchers for an idea.
     * @summary Get idea watchers
     * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetWatchers(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all ideas in the account.
     * @summary List ideas
     * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasList(requestParameters: IdeasApiIdeasListRequest = {}, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasList(requestParameters.page, requestParameters.perPage, requestParameters.fields, requestParameters.q, requestParameters.updatedSince, requestParameters.assignedToUser, requestParameters.status, requestParameters.category, requestParameters.productId, requestParameters.ideaPortalId, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of ideas for the specified product.
     * @summary List ideas for a product
     * @param {IdeasApiIdeasListProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasListProduct(requestParameters: IdeasApiIdeasListProductRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasListProduct(requestParameters.productId, requestParameters.q, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an idea as spam.
     * @summary Mark idea as spam
     * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasMarkSpam(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Promotes an idea to a feature, epic, or initiative.
     * @summary Promote an idea
     * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasPromote(requestParameters.id, requestParameters.ideaPromoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the spam flag from an idea.
     * @summary Unmark idea as spam
     * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUnmarkSpam(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of a specific idea.
     * @summary Update an idea
     * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUpdate(requestParameters.id, requestParameters.ideaUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the watchers for an idea.
     * @summary Update idea watchers
     * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUpdateWatchers(requestParameters.id, requestParameters.ideaWatchersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a vote to an idea.
     * @summary Vote on an idea
     * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasVote(requestParameters.id, requestParameters.ideaVoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const IdeasListSortEnum = {
    RECENT: 'recent',
    TRENDING: 'trending',
    POPULAR: 'popular'
} as const;
export type IdeasListSortEnum = typeof IdeasListSortEnum[keyof typeof IdeasListSortEnum];
export const IdeasListProductSortEnum = {
    RECENT: 'recent',
    TRENDING: 'trending',
    POPULAR: 'popular'
} as const;
export type IdeasListProductSortEnum = typeof IdeasListProductSortEnum[keyof typeof IdeasListProductSortEnum];
