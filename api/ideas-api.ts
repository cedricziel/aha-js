/* tslint:disable */
/* eslint-disable */
/**
 * Aha! REST API
 * API for interacting with Aha! product management platform.
 *
 * The version of the OpenAPI document: 1.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Comment } from '../model';
// @ts-ignore
import type { CommentCreateRequest } from '../model';
// @ts-ignore
import type { CommentsGetEpic200Response } from '../model';
// @ts-ignore
import type { IdeaCreateByPortalUserRequest } from '../model';
// @ts-ignore
import type { IdeaCreateRequest } from '../model';
// @ts-ignore
import type { IdeaEndorsementRequest } from '../model';
// @ts-ignore
import type { IdeaPromoteRequest } from '../model';
// @ts-ignore
import type { IdeaResponse } from '../model';
// @ts-ignore
import type { IdeaUpdateRequest } from '../model';
// @ts-ignore
import type { IdeaVoteRequest } from '../model';
// @ts-ignore
import type { IdeaWatchersRequest } from '../model';
// @ts-ignore
import type { IdeasCreateEndorsement201Response } from '../model';
// @ts-ignore
import type { IdeasGetEndorsements200Response } from '../model';
// @ts-ignore
import type { IdeasGetVotes200Response } from '../model';
// @ts-ignore
import type { IdeasGetWatchers200Response } from '../model';
// @ts-ignore
import type { IdeasListResponse } from '../model';
// @ts-ignore
import type { IdeasPromote200Response } from '../model';
// @ts-ignore
import type { IdeasVote200Response } from '../model';
/**
 * IdeasApi - axios parameter creator
 * @export
 */
export const IdeasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new comment to the specified idea.
         * @summary Create a comment on an idea
         * @param {string} ideaId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreateIdea: async (ideaId: string, commentCreateRequest: CommentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('commentsCreateIdea', 'ideaId', ideaId)
            // verify required parameter 'commentCreateRequest' is not null or undefined
            assertParamExists('commentsCreateIdea', 'commentCreateRequest', commentCreateRequest)
            const localVarPath = `/ideas/{idea_id}/comments`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetIdea: async (ideaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('commentsGetIdea', 'ideaId', ideaId)
            const localVarPath = `/ideas/{idea_id}/comments`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreate: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreate', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreate', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateByPortalUserRequest} ideaCreateByPortalUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateByPortalUser: async (productId: string, ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreateByPortalUser', 'productId', productId)
            // verify required parameter 'ideaCreateByPortalUserRequest' is not null or undefined
            assertParamExists('ideasCreateByPortalUser', 'ideaCreateByPortalUserRequest', ideaCreateByPortalUserRequest)
            const localVarPath = `/products/{product_id}/ideas/portal_user`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateByPortalUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaEndorsementRequest} ideaEndorsementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateEndorsement: async (id: string, ideaEndorsementRequest: IdeaEndorsementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasCreateEndorsement', 'id', id)
            // verify required parameter 'ideaEndorsementRequest' is not null or undefined
            assertParamExists('ideasCreateEndorsement', 'ideaEndorsementRequest', ideaEndorsementRequest)
            const localVarPath = `/ideas/{id}/endorsements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaEndorsementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithCategory: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreateWithCategory', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreateWithCategory', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas/with_category`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithScore: async (productId: string, ideaCreateRequest: IdeaCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasCreateWithScore', 'productId', productId)
            // verify required parameter 'ideaCreateRequest' is not null or undefined
            assertParamExists('ideasCreateWithScore', 'ideaCreateRequest', ideaCreateRequest)
            const localVarPath = `/products/{product_id}/ideas/with_score`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasDelete', 'id', id)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetById', 'id', id)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {boolean} [proxy] If set to true, only returns proxy votes (votes with an associated organization)
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of endorsements per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetEndorsements: async (id: string, proxy?: boolean, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetEndorsements', 'id', id)
            const localVarPath = `/ideas/{id}/endorsements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (proxy !== undefined) {
                localVarQueryParameter['proxy'] = proxy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of votes per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetVotes: async (id: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetVotes', 'id', id)
            const localVarPath = `/ideas/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetWatchers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasGetWatchers', 'id', id)
            const localVarPath = `/ideas/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {string} [q] Search term to match against idea name.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
         * @param {string} [assignedToUser] ID or email address of a user. If provided, returns only ideas assigned to that user.
         * @param {string} [status] Status filter for ideas.
         * @param {string} [category] Filter ideas by category.
         * @param {string} [productId] Filter ideas by product ID.
         * @param {string} [ideaPortalId] Filter ideas by idea portal ID.
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {number} [page] Page number for pagination.
         * @param {number} [perPage] Number of ideas per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasList: async (q?: string, updatedSince?: string, assignedToUser?: string, status?: string, category?: string, productId?: string, ideaPortalId?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListSortEnum, createdBefore?: string, createdSince?: string, tag?: string, userId?: string, ideaUserId?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ideas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (ideaPortalId !== undefined) {
                localVarQueryParameter['idea_portal_id'] = ideaPortalId;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }

            if (workflowStatus !== undefined) {
                localVarQueryParameter['workflow_status'] = workflowStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (ideaUserId !== undefined) {
                localVarQueryParameter['idea_user_id'] = ideaUserId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against the idea name
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListProductSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasListProduct: async (productId: string, q?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListProductSortEnum, createdBefore?: string, createdSince?: string, updatedSince?: string, tag?: string, userId?: string, ideaUserId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('ideasListProduct', 'productId', productId)
            const localVarPath = `/products/{product_id}/ideas`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }

            if (workflowStatus !== undefined) {
                localVarQueryParameter['workflow_status'] = workflowStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (ideaUserId !== undefined) {
                localVarQueryParameter['idea_user_id'] = ideaUserId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasMarkSpam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasMarkSpam', 'id', id)
            const localVarPath = `/ideas/{id}/spam`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaPromoteRequest} ideaPromoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasPromote: async (id: string, ideaPromoteRequest: IdeaPromoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasPromote', 'id', id)
            // verify required parameter 'ideaPromoteRequest' is not null or undefined
            assertParamExists('ideasPromote', 'ideaPromoteRequest', ideaPromoteRequest)
            const localVarPath = `/ideas/{id}/promote`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaPromoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUnmarkSpam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUnmarkSpam', 'id', id)
            const localVarPath = `/ideas/{id}/spam`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaUpdateRequest} ideaUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdate: async (id: string, ideaUpdateRequest: IdeaUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUpdate', 'id', id)
            // verify required parameter 'ideaUpdateRequest' is not null or undefined
            assertParamExists('ideasUpdate', 'ideaUpdateRequest', ideaUpdateRequest)
            const localVarPath = `/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaWatchersRequest} ideaWatchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdateWatchers: async (id: string, ideaWatchersRequest: IdeaWatchersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasUpdateWatchers', 'id', id)
            // verify required parameter 'ideaWatchersRequest' is not null or undefined
            assertParamExists('ideasUpdateWatchers', 'ideaWatchersRequest', ideaWatchersRequest)
            const localVarPath = `/ideas/{id}/watchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaWatchersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaVoteRequest} ideaVoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasVote: async (id: string, ideaVoteRequest: IdeaVoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideasVote', 'id', id)
            // verify required parameter 'ideaVoteRequest' is not null or undefined
            assertParamExists('ideasVote', 'ideaVoteRequest', ideaVoteRequest)
            const localVarPath = `/ideas/{id}/votes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaVoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdeasApi - functional programming interface
 * @export
 */
export const IdeasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdeasApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new comment to the specified idea.
         * @summary Create a comment on an idea
         * @param {string} ideaId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsCreateIdea(ideaId: string, commentCreateRequest: CommentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsCreateIdea(ideaId, commentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.commentsCreateIdea']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsGetIdea(ideaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentsGetEpic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsGetIdea(ideaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.commentsGetIdea']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreate(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreate(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateByPortalUserRequest} ideaCreateByPortalUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateByPortalUser(productId: string, ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateByPortalUser(productId, ideaCreateByPortalUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateByPortalUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaEndorsementRequest} ideaEndorsementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateEndorsement(id: string, ideaEndorsementRequest: IdeaEndorsementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasCreateEndorsement201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateEndorsement(id, ideaEndorsementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateEndorsement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateWithCategory(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateWithCategory(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateWithCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {string} productId Numeric ID or key of the product
         * @param {IdeaCreateRequest} ideaCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasCreateWithScore(productId: string, ideaCreateRequest: IdeaCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasCreateWithScore(productId, ideaCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasCreateWithScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {boolean} [proxy] If set to true, only returns proxy votes (votes with an associated organization)
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of endorsements per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetEndorsements(id: string, proxy?: boolean, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetEndorsements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetEndorsements(id, proxy, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetEndorsements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {number} [page] Page number for pagination
         * @param {number} [perPage] Number of votes per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetVotes(id: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetVotes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetVotes(id, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetVotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasGetWatchers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasGetWatchers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasGetWatchers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasGetWatchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {string} [q] Search term to match against idea name.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
         * @param {string} [assignedToUser] ID or email address of a user. If provided, returns only ideas assigned to that user.
         * @param {string} [status] Status filter for ideas.
         * @param {string} [category] Filter ideas by category.
         * @param {string} [productId] Filter ideas by product ID.
         * @param {string} [ideaPortalId] Filter ideas by idea portal ID.
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {number} [page] Page number for pagination.
         * @param {number} [perPage] Number of ideas per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasList(q?: string, updatedSince?: string, assignedToUser?: string, status?: string, category?: string, productId?: string, ideaPortalId?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListSortEnum, createdBefore?: string, createdSince?: string, tag?: string, userId?: string, ideaUserId?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasList(q, updatedSince, assignedToUser, status, category, productId, ideaPortalId, spam, workflowStatus, sort, createdBefore, createdSince, tag, userId, ideaUserId, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against the idea name
         * @param {boolean} [spam] When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
         * @param {string} [workflowStatus] When present, filters to ideas with the provided workflow status ID or name.
         * @param {IdeasListProductSortEnum} [sort] Sorting of the list of ideas. Accepted values are recent, trending, or popular.
         * @param {string} [createdBefore] UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
         * @param {string} [createdSince] UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
         * @param {string} [updatedSince] UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
         * @param {string} [tag] String tag value. If provided, only ideas with the associated tag will be returned.
         * @param {string} [userId] ID of a user. If provided, only ideas created by that user will be returned.
         * @param {string} [ideaUserId] ID of an idea user. If provided, only ideas created by that idea user will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasListProduct(productId: string, q?: string, spam?: boolean, workflowStatus?: string, sort?: IdeasListProductSortEnum, createdBefore?: string, createdSince?: string, updatedSince?: string, tag?: string, userId?: string, ideaUserId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasListProduct(productId, q, spam, workflowStatus, sort, createdBefore, createdSince, updatedSince, tag, userId, ideaUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasListProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasMarkSpam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasMarkSpam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasMarkSpam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaPromoteRequest} ideaPromoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasPromote(id: string, ideaPromoteRequest: IdeaPromoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasPromote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasPromote(id, ideaPromoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasPromote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {string} id Numeric ID or key of the idea
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUnmarkSpam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUnmarkSpam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUnmarkSpam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaUpdateRequest} ideaUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUpdate(id: string, ideaUpdateRequest: IdeaUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUpdate(id, ideaUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaWatchersRequest} ideaWatchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasUpdateWatchers(id: string, ideaWatchersRequest: IdeaWatchersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasUpdateWatchers(id, ideaWatchersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasUpdateWatchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {string} id Numeric ID or key of the idea
         * @param {IdeaVoteRequest} ideaVoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideasVote(id: string, ideaVoteRequest: IdeaVoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeasVote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideasVote(id, ideaVoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.ideasVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdeasApi - factory interface
 * @export
 */
export const IdeasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdeasApiFp(configuration)
    return {
        /**
         * Adds a new comment to the specified idea.
         * @summary Create a comment on an idea
         * @param {IdeasApiCommentsCreateIdeaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreateIdea(requestParameters: IdeasApiCommentsCreateIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.commentsCreateIdea(requestParameters.ideaId, requestParameters.commentCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of comments associated with the specified idea.
         * @summary List comments on an idea
         * @param {IdeasApiCommentsGetIdeaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetIdea(requestParameters: IdeasApiCommentsGetIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentsGetEpic200Response> {
            return localVarFp.commentsGetIdea(requestParameters.ideaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea
         * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreate(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea created by a ideas portal user
         * @param {IdeasApiIdeasCreateByPortalUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateByPortalUser(requestParameters: IdeasApiIdeasCreateByPortalUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreateByPortalUser(requestParameters.productId, requestParameters.ideaCreateByPortalUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an endorsement (proxy vote) on an idea on behalf of another user.
         * @summary Create an endorsement (proxy vote)
         * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasCreateEndorsement201Response> {
            return localVarFp.ideasCreateEndorsement(requestParameters.id, requestParameters.ideaEndorsementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a category
         * @param {IdeasApiIdeasCreateWithCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithCategory(requestParameters: IdeasApiIdeasCreateWithCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreateWithCategory(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
         * @summary Create an idea with a score
         * @param {IdeasApiIdeasCreateWithScoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasCreateWithScore(requestParameters: IdeasApiIdeasCreateWithScoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasCreateWithScore(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified idea.
         * @summary Delete an idea
         * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideasDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specific idea.
         * @summary Get a specific idea
         * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasGetById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all endorsements for a specific idea.
         * @summary Get endorsements for an idea
         * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetEndorsements200Response> {
            return localVarFp.ideasGetEndorsements(requestParameters.id, requestParameters.proxy, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all votes for a specific idea.
         * @summary Get votes for an idea
         * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetVotes200Response> {
            return localVarFp.ideasGetVotes(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the watchers for an idea.
         * @summary Get idea watchers
         * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetWatchers200Response> {
            return localVarFp.ideasGetWatchers(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all ideas in the account.
         * @summary List ideas
         * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasList(requestParameters: IdeasApiIdeasListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse> {
            return localVarFp.ideasList(requestParameters.q, requestParameters.updatedSince, requestParameters.assignedToUser, requestParameters.status, requestParameters.category, requestParameters.productId, requestParameters.ideaPortalId, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of ideas for the specified product.
         * @summary List ideas for a product
         * @param {IdeasApiIdeasListProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasListProduct(requestParameters: IdeasApiIdeasListProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse> {
            return localVarFp.ideasListProduct(requestParameters.productId, requestParameters.q, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks an idea as spam.
         * @summary Mark idea as spam
         * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasMarkSpam(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Promotes an idea to a feature, epic, or initiative.
         * @summary Promote an idea
         * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasPromote200Response> {
            return localVarFp.ideasPromote(requestParameters.id, requestParameters.ideaPromoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the spam flag from an idea.
         * @summary Unmark idea as spam
         * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUnmarkSpam(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of a specific idea.
         * @summary Update an idea
         * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUpdate(requestParameters.id, requestParameters.ideaUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the watchers for an idea.
         * @summary Update idea watchers
         * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse> {
            return localVarFp.ideasUpdateWatchers(requestParameters.id, requestParameters.ideaWatchersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a vote to an idea.
         * @summary Vote on an idea
         * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasVote200Response> {
            return localVarFp.ideasVote(requestParameters.id, requestParameters.ideaVoteRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdeasApi - interface
 * @export
 * @interface IdeasApi
 */
export interface IdeasApiInterface {
    /**
     * Adds a new comment to the specified idea.
     * @summary Create a comment on an idea
     * @param {IdeasApiCommentsCreateIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    commentsCreateIdea(requestParameters: IdeasApiCommentsCreateIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * Retrieves a list of comments associated with the specified idea.
     * @summary List comments on an idea
     * @param {IdeasApiCommentsGetIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    commentsGetIdea(requestParameters: IdeasApiCommentsGetIdeaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentsGetEpic200Response>;

    /**
     * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea
     * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea created by a ideas portal user
     * @param {IdeasApiIdeasCreateByPortalUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreateByPortalUser(requestParameters: IdeasApiIdeasCreateByPortalUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates an endorsement (proxy vote) on an idea on behalf of another user.
     * @summary Create an endorsement (proxy vote)
     * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasCreateEndorsement201Response>;

    /**
     * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a category
     * @param {IdeasApiIdeasCreateWithCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreateWithCategory(requestParameters: IdeasApiIdeasCreateWithCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a score
     * @param {IdeasApiIdeasCreateWithScoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasCreateWithScore(requestParameters: IdeasApiIdeasCreateWithScoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Deletes the specified idea.
     * @summary Delete an idea
     * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves the details of a specific idea.
     * @summary Get a specific idea
     * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Retrieves all endorsements for a specific idea.
     * @summary Get endorsements for an idea
     * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetEndorsements200Response>;

    /**
     * Retrieves all votes for a specific idea.
     * @summary Get votes for an idea
     * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetVotes200Response>;

    /**
     * Retrieves the watchers for an idea.
     * @summary Get idea watchers
     * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasGetWatchers200Response>;

    /**
     * Retrieves a list of all ideas in the account.
     * @summary List ideas
     * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasList(requestParameters?: IdeasApiIdeasListRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse>;

    /**
     * Retrieves a list of ideas for the specified product.
     * @summary List ideas for a product
     * @param {IdeasApiIdeasListProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasListProduct(requestParameters: IdeasApiIdeasListProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasListResponse>;

    /**
     * Marks an idea as spam.
     * @summary Mark idea as spam
     * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Promotes an idea to a feature, epic, or initiative.
     * @summary Promote an idea
     * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasPromote200Response>;

    /**
     * Removes the spam flag from an idea.
     * @summary Unmark idea as spam
     * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Updates the details of a specific idea.
     * @summary Update an idea
     * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Updates the watchers for an idea.
     * @summary Update idea watchers
     * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeaResponse>;

    /**
     * Adds a vote to an idea.
     * @summary Vote on an idea
     * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApiInterface
     */
    ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdeasVote200Response>;

}

/**
 * Request parameters for commentsCreateIdea operation in IdeasApi.
 * @export
 * @interface IdeasApiCommentsCreateIdeaRequest
 */
export interface IdeasApiCommentsCreateIdeaRequest {
    /**
     * 
     * @type {string}
     * @memberof IdeasApiCommentsCreateIdea
     */
    readonly ideaId: string

    /**
     * 
     * @type {CommentCreateRequest}
     * @memberof IdeasApiCommentsCreateIdea
     */
    readonly commentCreateRequest: CommentCreateRequest
}

/**
 * Request parameters for commentsGetIdea operation in IdeasApi.
 * @export
 * @interface IdeasApiCommentsGetIdeaRequest
 */
export interface IdeasApiCommentsGetIdeaRequest {
    /**
     * 
     * @type {string}
     * @memberof IdeasApiCommentsGetIdea
     */
    readonly ideaId: string
}

/**
 * Request parameters for ideasCreate operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateRequest
 */
export interface IdeasApiIdeasCreateRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiIdeasCreate
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateRequest}
     * @memberof IdeasApiIdeasCreate
     */
    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasCreateByPortalUser operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateByPortalUserRequest
 */
export interface IdeasApiIdeasCreateByPortalUserRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiIdeasCreateByPortalUser
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateByPortalUserRequest}
     * @memberof IdeasApiIdeasCreateByPortalUser
     */
    readonly ideaCreateByPortalUserRequest: IdeaCreateByPortalUserRequest
}

/**
 * Request parameters for ideasCreateEndorsement operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateEndorsementRequest
 */
export interface IdeasApiIdeasCreateEndorsementRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasCreateEndorsement
     */
    readonly id: string

    /**
     * 
     * @type {IdeaEndorsementRequest}
     * @memberof IdeasApiIdeasCreateEndorsement
     */
    readonly ideaEndorsementRequest: IdeaEndorsementRequest
}

/**
 * Request parameters for ideasCreateWithCategory operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateWithCategoryRequest
 */
export interface IdeasApiIdeasCreateWithCategoryRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiIdeasCreateWithCategory
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateRequest}
     * @memberof IdeasApiIdeasCreateWithCategory
     */
    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasCreateWithScore operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasCreateWithScoreRequest
 */
export interface IdeasApiIdeasCreateWithScoreRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiIdeasCreateWithScore
     */
    readonly productId: string

    /**
     * 
     * @type {IdeaCreateRequest}
     * @memberof IdeasApiIdeasCreateWithScore
     */
    readonly ideaCreateRequest: IdeaCreateRequest
}

/**
 * Request parameters for ideasDelete operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasDeleteRequest
 */
export interface IdeasApiIdeasDeleteRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasDelete
     */
    readonly id: string
}

/**
 * Request parameters for ideasGetById operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetByIdRequest
 */
export interface IdeasApiIdeasGetByIdRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetById
     */
    readonly id: string
}

/**
 * Request parameters for ideasGetEndorsements operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetEndorsementsRequest
 */
export interface IdeasApiIdeasGetEndorsementsRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly id: string

    /**
     * If set to true, only returns proxy votes (votes with an associated organization)
     * @type {boolean}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly proxy?: boolean

    /**
     * Page number for pagination
     * @type {number}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly page?: number

    /**
     * Number of endorsements per page
     * @type {number}
     * @memberof IdeasApiIdeasGetEndorsements
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasGetVotes operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetVotesRequest
 */
export interface IdeasApiIdeasGetVotesRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetVotes
     */
    readonly id: string

    /**
     * Page number for pagination
     * @type {number}
     * @memberof IdeasApiIdeasGetVotes
     */
    readonly page?: number

    /**
     * Number of votes per page
     * @type {number}
     * @memberof IdeasApiIdeasGetVotes
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasGetWatchers operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasGetWatchersRequest
 */
export interface IdeasApiIdeasGetWatchersRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasGetWatchers
     */
    readonly id: string
}

/**
 * Request parameters for ideasList operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasListRequest
 */
export interface IdeasApiIdeasListRequest {
    /**
     * Search term to match against idea name.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly q?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas updated after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly updatedSince?: string

    /**
     * ID or email address of a user. If provided, returns only ideas assigned to that user.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly assignedToUser?: string

    /**
     * Status filter for ideas.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly status?: string

    /**
     * Filter ideas by category.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly category?: string

    /**
     * Filter ideas by product ID.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly productId?: string

    /**
     * Filter ideas by idea portal ID.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly ideaPortalId?: string

    /**
     * When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
     * @type {boolean}
     * @memberof IdeasApiIdeasList
     */
    readonly spam?: boolean

    /**
     * When present, filters to ideas with the provided workflow status ID or name.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly workflowStatus?: string

    /**
     * Sorting of the list of ideas. Accepted values are recent, trending, or popular.
     * @type {'recent' | 'trending' | 'popular'}
     * @memberof IdeasApiIdeasList
     */
    readonly sort?: IdeasListSortEnum

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly createdBefore?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly createdSince?: string

    /**
     * String tag value. If provided, only ideas with the associated tag will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly tag?: string

    /**
     * ID of a user. If provided, only ideas created by that user will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly userId?: string

    /**
     * ID of an idea user. If provided, only ideas created by that idea user will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasList
     */
    readonly ideaUserId?: string

    /**
     * Page number for pagination.
     * @type {number}
     * @memberof IdeasApiIdeasList
     */
    readonly page?: number

    /**
     * Number of ideas per page.
     * @type {number}
     * @memberof IdeasApiIdeasList
     */
    readonly perPage?: number
}

/**
 * Request parameters for ideasListProduct operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasListProductRequest
 */
export interface IdeasApiIdeasListProductRequest {
    /**
     * Numeric ID or key of the product
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly productId: string

    /**
     * Search term to match against the idea name
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly q?: string

    /**
     * When true, shows ideas that have been marked as spam. By default, no spam ideas will be shown.
     * @type {boolean}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly spam?: boolean

    /**
     * When present, filters to ideas with the provided workflow status ID or name.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly workflowStatus?: string

    /**
     * Sorting of the list of ideas. Accepted values are recent, trending, or popular.
     * @type {'recent' | 'trending' | 'popular'}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly sort?: IdeasListProductSortEnum

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created before the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly createdBefore?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas created after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly createdSince?: string

    /**
     * UTC timestamp (in ISO8601 format). If provided, only ideas updated or created after the timestamp will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly updatedSince?: string

    /**
     * String tag value. If provided, only ideas with the associated tag will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly tag?: string

    /**
     * ID of a user. If provided, only ideas created by that user will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly userId?: string

    /**
     * ID of an idea user. If provided, only ideas created by that idea user will be returned.
     * @type {string}
     * @memberof IdeasApiIdeasListProduct
     */
    readonly ideaUserId?: string
}

/**
 * Request parameters for ideasMarkSpam operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasMarkSpamRequest
 */
export interface IdeasApiIdeasMarkSpamRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasMarkSpam
     */
    readonly id: string
}

/**
 * Request parameters for ideasPromote operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasPromoteRequest
 */
export interface IdeasApiIdeasPromoteRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasPromote
     */
    readonly id: string

    /**
     * 
     * @type {IdeaPromoteRequest}
     * @memberof IdeasApiIdeasPromote
     */
    readonly ideaPromoteRequest: IdeaPromoteRequest
}

/**
 * Request parameters for ideasUnmarkSpam operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasUnmarkSpamRequest
 */
export interface IdeasApiIdeasUnmarkSpamRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasUnmarkSpam
     */
    readonly id: string
}

/**
 * Request parameters for ideasUpdate operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasUpdateRequest
 */
export interface IdeasApiIdeasUpdateRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasUpdate
     */
    readonly id: string

    /**
     * 
     * @type {IdeaUpdateRequest}
     * @memberof IdeasApiIdeasUpdate
     */
    readonly ideaUpdateRequest: IdeaUpdateRequest
}

/**
 * Request parameters for ideasUpdateWatchers operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasUpdateWatchersRequest
 */
export interface IdeasApiIdeasUpdateWatchersRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasUpdateWatchers
     */
    readonly id: string

    /**
     * 
     * @type {IdeaWatchersRequest}
     * @memberof IdeasApiIdeasUpdateWatchers
     */
    readonly ideaWatchersRequest: IdeaWatchersRequest
}

/**
 * Request parameters for ideasVote operation in IdeasApi.
 * @export
 * @interface IdeasApiIdeasVoteRequest
 */
export interface IdeasApiIdeasVoteRequest {
    /**
     * Numeric ID or key of the idea
     * @type {string}
     * @memberof IdeasApiIdeasVote
     */
    readonly id: string

    /**
     * 
     * @type {IdeaVoteRequest}
     * @memberof IdeasApiIdeasVote
     */
    readonly ideaVoteRequest: IdeaVoteRequest
}

/**
 * IdeasApi - object-oriented interface
 * @export
 * @class IdeasApi
 * @extends {BaseAPI}
 */
export class IdeasApi extends BaseAPI implements IdeasApiInterface {
    /**
     * Adds a new comment to the specified idea.
     * @summary Create a comment on an idea
     * @param {IdeasApiCommentsCreateIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public commentsCreateIdea(requestParameters: IdeasApiCommentsCreateIdeaRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).commentsCreateIdea(requestParameters.ideaId, requestParameters.commentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of comments associated with the specified idea.
     * @summary List comments on an idea
     * @param {IdeasApiCommentsGetIdeaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public commentsGetIdea(requestParameters: IdeasApiCommentsGetIdeaRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).commentsGetIdea(requestParameters.ideaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea
     * @param {IdeasApiIdeasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreate(requestParameters: IdeasApiIdeasCreateRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreate(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product, where the creator is an ideas portal user.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea created by a ideas portal user
     * @param {IdeasApiIdeasCreateByPortalUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreateByPortalUser(requestParameters: IdeasApiIdeasCreateByPortalUserRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateByPortalUser(requestParameters.productId, requestParameters.ideaCreateByPortalUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an endorsement (proxy vote) on an idea on behalf of another user.
     * @summary Create an endorsement (proxy vote)
     * @param {IdeasApiIdeasCreateEndorsementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreateEndorsement(requestParameters: IdeasApiIdeasCreateEndorsementRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateEndorsement(requestParameters.id, requestParameters.ideaEndorsementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product with a category.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a category
     * @param {IdeasApiIdeasCreateWithCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreateWithCategory(requestParameters: IdeasApiIdeasCreateWithCategoryRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateWithCategory(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new idea for the specified product with a score.  When creating an idea where the creator is an idea user we strongly suggest to provide the submitted_idea_portal_id attribute to the idea to ensure that the idea is created in the correct ideas portal and the user gets access to the portal.  If you don\'t want the idea to be submitted to any portal, you can skip this by setting skip_portal: true in the request body. 
     * @summary Create an idea with a score
     * @param {IdeasApiIdeasCreateWithScoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasCreateWithScore(requestParameters: IdeasApiIdeasCreateWithScoreRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasCreateWithScore(requestParameters.productId, requestParameters.ideaCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified idea.
     * @summary Delete an idea
     * @param {IdeasApiIdeasDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasDelete(requestParameters: IdeasApiIdeasDeleteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specific idea.
     * @summary Get a specific idea
     * @param {IdeasApiIdeasGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetById(requestParameters: IdeasApiIdeasGetByIdRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all endorsements for a specific idea.
     * @summary Get endorsements for an idea
     * @param {IdeasApiIdeasGetEndorsementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetEndorsements(requestParameters: IdeasApiIdeasGetEndorsementsRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetEndorsements(requestParameters.id, requestParameters.proxy, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all votes for a specific idea.
     * @summary Get votes for an idea
     * @param {IdeasApiIdeasGetVotesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetVotes(requestParameters: IdeasApiIdeasGetVotesRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetVotes(requestParameters.id, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the watchers for an idea.
     * @summary Get idea watchers
     * @param {IdeasApiIdeasGetWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasGetWatchers(requestParameters: IdeasApiIdeasGetWatchersRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasGetWatchers(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all ideas in the account.
     * @summary List ideas
     * @param {IdeasApiIdeasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasList(requestParameters: IdeasApiIdeasListRequest = {}, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasList(requestParameters.q, requestParameters.updatedSince, requestParameters.assignedToUser, requestParameters.status, requestParameters.category, requestParameters.productId, requestParameters.ideaPortalId, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of ideas for the specified product.
     * @summary List ideas for a product
     * @param {IdeasApiIdeasListProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasListProduct(requestParameters: IdeasApiIdeasListProductRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasListProduct(requestParameters.productId, requestParameters.q, requestParameters.spam, requestParameters.workflowStatus, requestParameters.sort, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedSince, requestParameters.tag, requestParameters.userId, requestParameters.ideaUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an idea as spam.
     * @summary Mark idea as spam
     * @param {IdeasApiIdeasMarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasMarkSpam(requestParameters: IdeasApiIdeasMarkSpamRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasMarkSpam(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Promotes an idea to a feature, epic, or initiative.
     * @summary Promote an idea
     * @param {IdeasApiIdeasPromoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasPromote(requestParameters: IdeasApiIdeasPromoteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasPromote(requestParameters.id, requestParameters.ideaPromoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the spam flag from an idea.
     * @summary Unmark idea as spam
     * @param {IdeasApiIdeasUnmarkSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasUnmarkSpam(requestParameters: IdeasApiIdeasUnmarkSpamRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUnmarkSpam(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of a specific idea.
     * @summary Update an idea
     * @param {IdeasApiIdeasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasUpdate(requestParameters: IdeasApiIdeasUpdateRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUpdate(requestParameters.id, requestParameters.ideaUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the watchers for an idea.
     * @summary Update idea watchers
     * @param {IdeasApiIdeasUpdateWatchersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasUpdateWatchers(requestParameters: IdeasApiIdeasUpdateWatchersRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasUpdateWatchers(requestParameters.id, requestParameters.ideaWatchersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a vote to an idea.
     * @summary Vote on an idea
     * @param {IdeasApiIdeasVoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public ideasVote(requestParameters: IdeasApiIdeasVoteRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).ideasVote(requestParameters.id, requestParameters.ideaVoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const IdeasListSortEnum = {
    RECENT: 'recent',
    TRENDING: 'trending',
    POPULAR: 'popular'
} as const;
export type IdeasListSortEnum = typeof IdeasListSortEnum[keyof typeof IdeasListSortEnum];
/**
 * @export
 */
export const IdeasListProductSortEnum = {
    RECENT: 'recent',
    TRENDING: 'trending',
    POPULAR: 'popular'
} as const;
export type IdeasListProductSortEnum = typeof IdeasListProductSortEnum[keyof typeof IdeasListProductSortEnum];
