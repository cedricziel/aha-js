/* tslint:disable */
/* eslint-disable */
/**
 * Aha! REST API
 * API for interacting with Aha! product management platform.  ## Rate Limiting The API enforces rate limits to ensure fair usage: - **300 requests per minute** per account - **20 requests per second** per account  When rate limits are exceeded, the API returns a `429 Too Many Requests` response with a `retry_after` header indicating when to retry.  ## Authentication The API supports two authentication methods: - **OAuth 2.0**: For web applications and integrations requiring user consent - **API Tokens**: For server-to-server integrations and personal access  ## Request Headers - **User-Agent**: Required header to identify the client application - **Content-Type**: Set to `application/json` for POST/PUT requests - **Authorization**: Bearer token or OAuth access token  ## Response Format All responses are in JSON format. List endpoints include pagination metadata in the `meta.pagination` object.  ## Error Handling The API uses standard HTTP status codes and includes detailed error messages in the response body for debugging. 
 *
 * The version of the OpenAPI document: 1.0.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Comment } from '../model';
// @ts-ignore
import type { CommentCreateRequest } from '../model';
// @ts-ignore
import type { CommentsGetEpic200Response } from '../model';
// @ts-ignore
import type { Epic } from '../model';
// @ts-ignore
import type { EpicCreateRequest } from '../model';
// @ts-ignore
import type { EpicUpdateRequest } from '../model';
// @ts-ignore
import type { EpicsList200Response } from '../model';
/**
 * EpicsApi - axios parameter creator
 */
export const EpicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new comment to the specified epic.
         * @summary Create a comment on an epic
         * @param {string} epicId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreateEpic: async (epicId: string, commentCreateRequest: CommentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epicId' is not null or undefined
            assertParamExists('commentsCreateEpic', 'epicId', epicId)
            // verify required parameter 'commentCreateRequest' is not null or undefined
            assertParamExists('commentsCreateEpic', 'commentCreateRequest', commentCreateRequest)
            const localVarPath = `/epics/{epic_id}/comments`
                .replace(`{${"epic_id"}}`, encodeURIComponent(String(epicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of comments associated with the specified epic.
         * @summary List comments on an epic
         * @param {string} epicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetEpic: async (epicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epicId' is not null or undefined
            assertParamExists('commentsGetEpic', 'epicId', epicId)
            const localVarPath = `/epics/{epic_id}/comments`
                .replace(`{${"epic_id"}}`, encodeURIComponent(String(epicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new epic in the specified product.
         * @summary Create an epic in a product
         * @param {string} productId Numeric ID or key of the product the epic should be created in
         * @param {EpicCreateRequest} epicCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsCreateInProduct: async (productId: string, epicCreateRequest: EpicCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('epicsCreateInProduct', 'productId', productId)
            // verify required parameter 'epicCreateRequest' is not null or undefined
            assertParamExists('epicsCreateInProduct', 'epicCreateRequest', epicCreateRequest)
            const localVarPath = `/products/{product_id}/epics`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(epicCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new epic in the specified release.
         * @summary Create an epic in a release
         * @param {string} releaseId Numeric ID or key of the release the epic should be created in
         * @param {EpicCreateRequest} epicCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsCreateInRelease: async (releaseId: string, epicCreateRequest: EpicCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'releaseId' is not null or undefined
            assertParamExists('epicsCreateInRelease', 'releaseId', releaseId)
            // verify required parameter 'epicCreateRequest' is not null or undefined
            assertParamExists('epicsCreateInRelease', 'epicCreateRequest', epicCreateRequest)
            const localVarPath = `/releases/{release_id}/epics`
                .replace(`{${"release_id"}}`, encodeURIComponent(String(releaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(epicCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified epic.
         * @summary Delete an epic
         * @param {string} epicId Numeric ID or key of the epic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsDelete: async (epicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epicId' is not null or undefined
            assertParamExists('epicsDelete', 'epicId', epicId)
            const localVarPath = `/epics/{epic_id}`
                .replace(`{${"epic_id"}}`, encodeURIComponent(String(epicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details of a specific epic by its ID.
         * @summary Get a specific epic
         * @param {string} epicId Numeric ID or key of the epic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsGet: async (epicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epicId' is not null or undefined
            assertParamExists('epicsGet', 'epicId', epicId)
            const localVarPath = `/epics/{epic_id}`
                .replace(`{${"epic_id"}}`, encodeURIComponent(String(epicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of epics with optional filtering by search term, updated date, tags, and assignee.
         * @summary List epics
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsList: async (q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/epics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of epics associated with the specified goal.
         * @summary List epics associated with a goal
         * @param {string} goalId Numeric ID or key of the goal
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListByGoal: async (goalId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('epicsListByGoal', 'goalId', goalId)
            const localVarPath = `/goals/{goal_id}/epics`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of epics associated with the specified initiative.
         * @summary List epics associated with an initiative
         * @param {string} initiativeId Numeric ID or key of the initiative
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListByInitiative: async (initiativeId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiativeId' is not null or undefined
            assertParamExists('epicsListByInitiative', 'initiativeId', initiativeId)
            const localVarPath = `/initiatives/{initiative_id}/epics`
                .replace(`{${"initiative_id"}}`, encodeURIComponent(String(initiativeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of epics associated with the specified product.
         * @summary List epics in a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListInProduct: async (productId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('epicsListInProduct', 'productId', productId)
            const localVarPath = `/products/{product_id}/epics`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of epics associated with the specified release.
         * @summary List epics in a release
         * @param {string} releaseId Numeric ID or key of the release
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListInRelease: async (releaseId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'releaseId' is not null or undefined
            assertParamExists('epicsListInRelease', 'releaseId', releaseId)
            const localVarPath = `/releases/{release_id}/epics`
                .replace(`{${"release_id"}}`, encodeURIComponent(String(releaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (assignedToUser !== undefined) {
                localVarQueryParameter['assigned_to_user'] = assignedToUser;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of the specified epic.
         * @summary Update an epic
         * @param {string} epicId Numeric ID or key of the epic
         * @param {EpicUpdateRequest} epicUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsUpdate: async (epicId: string, epicUpdateRequest: EpicUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epicId' is not null or undefined
            assertParamExists('epicsUpdate', 'epicId', epicId)
            // verify required parameter 'epicUpdateRequest' is not null or undefined
            assertParamExists('epicsUpdate', 'epicUpdateRequest', epicUpdateRequest)
            const localVarPath = `/epics/{epic_id}`
                .replace(`{${"epic_id"}}`, encodeURIComponent(String(epicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(epicUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EpicsApi - functional programming interface
 */
export const EpicsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EpicsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new comment to the specified epic.
         * @summary Create a comment on an epic
         * @param {string} epicId 
         * @param {CommentCreateRequest} commentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsCreateEpic(epicId: string, commentCreateRequest: CommentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsCreateEpic(epicId, commentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.commentsCreateEpic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of comments associated with the specified epic.
         * @summary List comments on an epic
         * @param {string} epicId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsGetEpic(epicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentsGetEpic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsGetEpic(epicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.commentsGetEpic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new epic in the specified product.
         * @summary Create an epic in a product
         * @param {string} productId Numeric ID or key of the product the epic should be created in
         * @param {EpicCreateRequest} epicCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsCreateInProduct(productId: string, epicCreateRequest: EpicCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Epic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsCreateInProduct(productId, epicCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsCreateInProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new epic in the specified release.
         * @summary Create an epic in a release
         * @param {string} releaseId Numeric ID or key of the release the epic should be created in
         * @param {EpicCreateRequest} epicCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsCreateInRelease(releaseId: string, epicCreateRequest: EpicCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Epic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsCreateInRelease(releaseId, epicCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsCreateInRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified epic.
         * @summary Delete an epic
         * @param {string} epicId Numeric ID or key of the epic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsDelete(epicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsDelete(epicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details of a specific epic by its ID.
         * @summary Get a specific epic
         * @param {string} epicId Numeric ID or key of the epic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsGet(epicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Epic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsGet(epicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of epics with optional filtering by search term, updated date, tags, and assignee.
         * @summary List epics
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsList(q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpicsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsList(q, updatedSince, tag, assignedToUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of epics associated with the specified goal.
         * @summary List epics associated with a goal
         * @param {string} goalId Numeric ID or key of the goal
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsListByGoal(goalId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpicsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsListByGoal(goalId, q, updatedSince, tag, assignedToUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsListByGoal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of epics associated with the specified initiative.
         * @summary List epics associated with an initiative
         * @param {string} initiativeId Numeric ID or key of the initiative
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsListByInitiative(initiativeId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpicsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsListByInitiative(initiativeId, q, updatedSince, tag, assignedToUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsListByInitiative']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of epics associated with the specified product.
         * @summary List epics in a product
         * @param {string} productId Numeric ID or key of the product
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsListInProduct(productId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpicsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsListInProduct(productId, q, updatedSince, tag, assignedToUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsListInProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of epics associated with the specified release.
         * @summary List epics in a release
         * @param {string} releaseId Numeric ID or key of the release
         * @param {string} [q] Search term to match against epic name
         * @param {string} [updatedSince] UTC timestamp for filtering recently updated epics
         * @param {string} [tag] String tag to filter epics
         * @param {string} [assignedToUser] User ID or email to filter by assignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsListInRelease(releaseId: string, q?: string, updatedSince?: string, tag?: string, assignedToUser?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpicsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsListInRelease(releaseId, q, updatedSince, tag, assignedToUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsListInRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the details of the specified epic.
         * @summary Update an epic
         * @param {string} epicId Numeric ID or key of the epic
         * @param {EpicUpdateRequest} epicUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async epicsUpdate(epicId: string, epicUpdateRequest: EpicUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Epic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.epicsUpdate(epicId, epicUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EpicsApi.epicsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EpicsApi - factory interface
 */
export const EpicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EpicsApiFp(configuration)
    return {
        /**
         * Adds a new comment to the specified epic.
         * @summary Create a comment on an epic
         * @param {EpicsApiCommentsCreateEpicRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreateEpic(requestParameters: EpicsApiCommentsCreateEpicRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.commentsCreateEpic(requestParameters.epicId, requestParameters.commentCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of comments associated with the specified epic.
         * @summary List comments on an epic
         * @param {EpicsApiCommentsGetEpicRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsGetEpic(requestParameters: EpicsApiCommentsGetEpicRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentsGetEpic200Response> {
            return localVarFp.commentsGetEpic(requestParameters.epicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new epic in the specified product.
         * @summary Create an epic in a product
         * @param {EpicsApiEpicsCreateInProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsCreateInProduct(requestParameters: EpicsApiEpicsCreateInProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic> {
            return localVarFp.epicsCreateInProduct(requestParameters.productId, requestParameters.epicCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new epic in the specified release.
         * @summary Create an epic in a release
         * @param {EpicsApiEpicsCreateInReleaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsCreateInRelease(requestParameters: EpicsApiEpicsCreateInReleaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic> {
            return localVarFp.epicsCreateInRelease(requestParameters.releaseId, requestParameters.epicCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified epic.
         * @summary Delete an epic
         * @param {EpicsApiEpicsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsDelete(requestParameters: EpicsApiEpicsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.epicsDelete(requestParameters.epicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details of a specific epic by its ID.
         * @summary Get a specific epic
         * @param {EpicsApiEpicsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsGet(requestParameters: EpicsApiEpicsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic> {
            return localVarFp.epicsGet(requestParameters.epicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of epics with optional filtering by search term, updated date, tags, and assignee.
         * @summary List epics
         * @param {EpicsApiEpicsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsList(requestParameters: EpicsApiEpicsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response> {
            return localVarFp.epicsList(requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of epics associated with the specified goal.
         * @summary List epics associated with a goal
         * @param {EpicsApiEpicsListByGoalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListByGoal(requestParameters: EpicsApiEpicsListByGoalRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response> {
            return localVarFp.epicsListByGoal(requestParameters.goalId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of epics associated with the specified initiative.
         * @summary List epics associated with an initiative
         * @param {EpicsApiEpicsListByInitiativeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListByInitiative(requestParameters: EpicsApiEpicsListByInitiativeRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response> {
            return localVarFp.epicsListByInitiative(requestParameters.initiativeId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of epics associated with the specified product.
         * @summary List epics in a product
         * @param {EpicsApiEpicsListInProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListInProduct(requestParameters: EpicsApiEpicsListInProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response> {
            return localVarFp.epicsListInProduct(requestParameters.productId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of epics associated with the specified release.
         * @summary List epics in a release
         * @param {EpicsApiEpicsListInReleaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsListInRelease(requestParameters: EpicsApiEpicsListInReleaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response> {
            return localVarFp.epicsListInRelease(requestParameters.releaseId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the specified epic.
         * @summary Update an epic
         * @param {EpicsApiEpicsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        epicsUpdate(requestParameters: EpicsApiEpicsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic> {
            return localVarFp.epicsUpdate(requestParameters.epicId, requestParameters.epicUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EpicsApi - interface
 */
export interface EpicsApiInterface {
    /**
     * Adds a new comment to the specified epic.
     * @summary Create a comment on an epic
     * @param {EpicsApiCommentsCreateEpicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commentsCreateEpic(requestParameters: EpicsApiCommentsCreateEpicRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * Retrieves a list of comments associated with the specified epic.
     * @summary List comments on an epic
     * @param {EpicsApiCommentsGetEpicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commentsGetEpic(requestParameters: EpicsApiCommentsGetEpicRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentsGetEpic200Response>;

    /**
     * Creates a new epic in the specified product.
     * @summary Create an epic in a product
     * @param {EpicsApiEpicsCreateInProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsCreateInProduct(requestParameters: EpicsApiEpicsCreateInProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic>;

    /**
     * Creates a new epic in the specified release.
     * @summary Create an epic in a release
     * @param {EpicsApiEpicsCreateInReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsCreateInRelease(requestParameters: EpicsApiEpicsCreateInReleaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic>;

    /**
     * Deletes the specified epic.
     * @summary Delete an epic
     * @param {EpicsApiEpicsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsDelete(requestParameters: EpicsApiEpicsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves details of a specific epic by its ID.
     * @summary Get a specific epic
     * @param {EpicsApiEpicsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsGet(requestParameters: EpicsApiEpicsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic>;

    /**
     * Retrieves a list of epics with optional filtering by search term, updated date, tags, and assignee.
     * @summary List epics
     * @param {EpicsApiEpicsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsList(requestParameters?: EpicsApiEpicsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response>;

    /**
     * Retrieves a list of epics associated with the specified goal.
     * @summary List epics associated with a goal
     * @param {EpicsApiEpicsListByGoalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsListByGoal(requestParameters: EpicsApiEpicsListByGoalRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response>;

    /**
     * Retrieves a list of epics associated with the specified initiative.
     * @summary List epics associated with an initiative
     * @param {EpicsApiEpicsListByInitiativeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsListByInitiative(requestParameters: EpicsApiEpicsListByInitiativeRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response>;

    /**
     * Retrieves a list of epics associated with the specified product.
     * @summary List epics in a product
     * @param {EpicsApiEpicsListInProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsListInProduct(requestParameters: EpicsApiEpicsListInProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response>;

    /**
     * Retrieves a list of epics associated with the specified release.
     * @summary List epics in a release
     * @param {EpicsApiEpicsListInReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsListInRelease(requestParameters: EpicsApiEpicsListInReleaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<EpicsList200Response>;

    /**
     * Updates the details of the specified epic.
     * @summary Update an epic
     * @param {EpicsApiEpicsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    epicsUpdate(requestParameters: EpicsApiEpicsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Epic>;

}

/**
 * Request parameters for commentsCreateEpic operation in EpicsApi.
 */
export interface EpicsApiCommentsCreateEpicRequest {
    readonly epicId: string

    readonly commentCreateRequest: CommentCreateRequest
}

/**
 * Request parameters for commentsGetEpic operation in EpicsApi.
 */
export interface EpicsApiCommentsGetEpicRequest {
    readonly epicId: string
}

/**
 * Request parameters for epicsCreateInProduct operation in EpicsApi.
 */
export interface EpicsApiEpicsCreateInProductRequest {
    /**
     * Numeric ID or key of the product the epic should be created in
     */
    readonly productId: string

    readonly epicCreateRequest: EpicCreateRequest
}

/**
 * Request parameters for epicsCreateInRelease operation in EpicsApi.
 */
export interface EpicsApiEpicsCreateInReleaseRequest {
    /**
     * Numeric ID or key of the release the epic should be created in
     */
    readonly releaseId: string

    readonly epicCreateRequest: EpicCreateRequest
}

/**
 * Request parameters for epicsDelete operation in EpicsApi.
 */
export interface EpicsApiEpicsDeleteRequest {
    /**
     * Numeric ID or key of the epic
     */
    readonly epicId: string
}

/**
 * Request parameters for epicsGet operation in EpicsApi.
 */
export interface EpicsApiEpicsGetRequest {
    /**
     * Numeric ID or key of the epic
     */
    readonly epicId: string
}

/**
 * Request parameters for epicsList operation in EpicsApi.
 */
export interface EpicsApiEpicsListRequest {
    /**
     * Search term to match against epic name
     */
    readonly q?: string

    /**
     * UTC timestamp for filtering recently updated epics
     */
    readonly updatedSince?: string

    /**
     * String tag to filter epics
     */
    readonly tag?: string

    /**
     * User ID or email to filter by assignee
     */
    readonly assignedToUser?: string
}

/**
 * Request parameters for epicsListByGoal operation in EpicsApi.
 */
export interface EpicsApiEpicsListByGoalRequest {
    /**
     * Numeric ID or key of the goal
     */
    readonly goalId: string

    /**
     * Search term to match against epic name
     */
    readonly q?: string

    /**
     * UTC timestamp for filtering recently updated epics
     */
    readonly updatedSince?: string

    /**
     * String tag to filter epics
     */
    readonly tag?: string

    /**
     * User ID or email to filter by assignee
     */
    readonly assignedToUser?: string
}

/**
 * Request parameters for epicsListByInitiative operation in EpicsApi.
 */
export interface EpicsApiEpicsListByInitiativeRequest {
    /**
     * Numeric ID or key of the initiative
     */
    readonly initiativeId: string

    /**
     * Search term to match against epic name
     */
    readonly q?: string

    /**
     * UTC timestamp for filtering recently updated epics
     */
    readonly updatedSince?: string

    /**
     * String tag to filter epics
     */
    readonly tag?: string

    /**
     * User ID or email to filter by assignee
     */
    readonly assignedToUser?: string
}

/**
 * Request parameters for epicsListInProduct operation in EpicsApi.
 */
export interface EpicsApiEpicsListInProductRequest {
    /**
     * Numeric ID or key of the product
     */
    readonly productId: string

    /**
     * Search term to match against epic name
     */
    readonly q?: string

    /**
     * UTC timestamp for filtering recently updated epics
     */
    readonly updatedSince?: string

    /**
     * String tag to filter epics
     */
    readonly tag?: string

    /**
     * User ID or email to filter by assignee
     */
    readonly assignedToUser?: string
}

/**
 * Request parameters for epicsListInRelease operation in EpicsApi.
 */
export interface EpicsApiEpicsListInReleaseRequest {
    /**
     * Numeric ID or key of the release
     */
    readonly releaseId: string

    /**
     * Search term to match against epic name
     */
    readonly q?: string

    /**
     * UTC timestamp for filtering recently updated epics
     */
    readonly updatedSince?: string

    /**
     * String tag to filter epics
     */
    readonly tag?: string

    /**
     * User ID or email to filter by assignee
     */
    readonly assignedToUser?: string
}

/**
 * Request parameters for epicsUpdate operation in EpicsApi.
 */
export interface EpicsApiEpicsUpdateRequest {
    /**
     * Numeric ID or key of the epic
     */
    readonly epicId: string

    readonly epicUpdateRequest: EpicUpdateRequest
}

/**
 * EpicsApi - object-oriented interface
 */
export class EpicsApi extends BaseAPI implements EpicsApiInterface {
    /**
     * Adds a new comment to the specified epic.
     * @summary Create a comment on an epic
     * @param {EpicsApiCommentsCreateEpicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commentsCreateEpic(requestParameters: EpicsApiCommentsCreateEpicRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).commentsCreateEpic(requestParameters.epicId, requestParameters.commentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of comments associated with the specified epic.
     * @summary List comments on an epic
     * @param {EpicsApiCommentsGetEpicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commentsGetEpic(requestParameters: EpicsApiCommentsGetEpicRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).commentsGetEpic(requestParameters.epicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new epic in the specified product.
     * @summary Create an epic in a product
     * @param {EpicsApiEpicsCreateInProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsCreateInProduct(requestParameters: EpicsApiEpicsCreateInProductRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsCreateInProduct(requestParameters.productId, requestParameters.epicCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new epic in the specified release.
     * @summary Create an epic in a release
     * @param {EpicsApiEpicsCreateInReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsCreateInRelease(requestParameters: EpicsApiEpicsCreateInReleaseRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsCreateInRelease(requestParameters.releaseId, requestParameters.epicCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified epic.
     * @summary Delete an epic
     * @param {EpicsApiEpicsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsDelete(requestParameters: EpicsApiEpicsDeleteRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsDelete(requestParameters.epicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details of a specific epic by its ID.
     * @summary Get a specific epic
     * @param {EpicsApiEpicsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsGet(requestParameters: EpicsApiEpicsGetRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsGet(requestParameters.epicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of epics with optional filtering by search term, updated date, tags, and assignee.
     * @summary List epics
     * @param {EpicsApiEpicsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsList(requestParameters: EpicsApiEpicsListRequest = {}, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsList(requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of epics associated with the specified goal.
     * @summary List epics associated with a goal
     * @param {EpicsApiEpicsListByGoalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsListByGoal(requestParameters: EpicsApiEpicsListByGoalRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsListByGoal(requestParameters.goalId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of epics associated with the specified initiative.
     * @summary List epics associated with an initiative
     * @param {EpicsApiEpicsListByInitiativeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsListByInitiative(requestParameters: EpicsApiEpicsListByInitiativeRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsListByInitiative(requestParameters.initiativeId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of epics associated with the specified product.
     * @summary List epics in a product
     * @param {EpicsApiEpicsListInProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsListInProduct(requestParameters: EpicsApiEpicsListInProductRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsListInProduct(requestParameters.productId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of epics associated with the specified release.
     * @summary List epics in a release
     * @param {EpicsApiEpicsListInReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsListInRelease(requestParameters: EpicsApiEpicsListInReleaseRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsListInRelease(requestParameters.releaseId, requestParameters.q, requestParameters.updatedSince, requestParameters.tag, requestParameters.assignedToUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of the specified epic.
     * @summary Update an epic
     * @param {EpicsApiEpicsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public epicsUpdate(requestParameters: EpicsApiEpicsUpdateRequest, options?: RawAxiosRequestConfig) {
        return EpicsApiFp(this.configuration).epicsUpdate(requestParameters.epicId, requestParameters.epicUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

